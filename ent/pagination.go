// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/facebook/ent/dialect/sql"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/remotefile"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// BuildEdge is the edge representation of Build.
type BuildEdge struct {
	Node   *Build `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BuildConnection is the connection containing edges to Build.
type BuildConnection struct {
	Edges      []*BuildEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// BuildPaginateOption enables pagination customization.
type BuildPaginateOption func(*buildPager) error

// WithBuildOrder configures pagination ordering.
func WithBuildOrder(order *BuildOrder) BuildPaginateOption {
	if order == nil {
		order = DefaultBuildOrder
	}
	o := *order
	return func(pager *buildPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBuildOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBuildFilter configures pagination filter.
func WithBuildFilter(filter func(*BuildQuery) (*BuildQuery, error)) BuildPaginateOption {
	return func(pager *buildPager) error {
		if filter == nil {
			return errors.New("BuildQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type buildPager struct {
	order  *BuildOrder
	filter func(*BuildQuery) (*BuildQuery, error)
}

func newBuildPager(opts []BuildPaginateOption) (*buildPager, error) {
	pager := &buildPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBuildOrder
	}
	return pager, nil
}

func (p *buildPager) applyFilter(query *BuildQuery) (*BuildQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *buildPager) toCursor(b *Build) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *buildPager) applyCursors(query *BuildQuery, after, before *Cursor) *BuildQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBuildOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *buildPager) applyOrder(query *BuildQuery, reverse bool) *BuildQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBuildOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBuildOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Build.
func (b *BuildQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BuildPaginateOption,
) (*BuildConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBuildPager(opts)
	if err != nil {
		return nil, err
	}

	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}

	conn := &BuildConnection{Edges: []*BuildEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := b.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := b.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	b = pager.applyCursors(b, after, before)
	b = pager.applyOrder(b, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		b = b.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		b = b.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := b.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Build
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Build {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Build {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BuildEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BuildEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// BuildOrderField defines the ordering field of Build.
type BuildOrderField struct {
	field    string
	toCursor func(*Build) Cursor
}

// BuildOrder defines the ordering of Build.
type BuildOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *BuildOrderField `json:"field"`
}

// DefaultBuildOrder is the default ordering of Build.
var DefaultBuildOrder = &BuildOrder{
	Direction: OrderDirectionAsc,
	Field: &BuildOrderField{
		field: build.FieldID,
		toCursor: func(b *Build) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Build into BuildEdge.
func (b *Build) ToEdge(order *BuildOrder) *BuildEdge {
	if order == nil {
		order = DefaultBuildOrder
	}
	return &BuildEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// CommandEdge is the edge representation of Command.
type CommandEdge struct {
	Node   *Command `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CommandConnection is the connection containing edges to Command.
type CommandConnection struct {
	Edges      []*CommandEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// CommandPaginateOption enables pagination customization.
type CommandPaginateOption func(*commandPager) error

// WithCommandOrder configures pagination ordering.
func WithCommandOrder(order *CommandOrder) CommandPaginateOption {
	if order == nil {
		order = DefaultCommandOrder
	}
	o := *order
	return func(pager *commandPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCommandOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCommandFilter configures pagination filter.
func WithCommandFilter(filter func(*CommandQuery) (*CommandQuery, error)) CommandPaginateOption {
	return func(pager *commandPager) error {
		if filter == nil {
			return errors.New("CommandQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commandPager struct {
	order  *CommandOrder
	filter func(*CommandQuery) (*CommandQuery, error)
}

func newCommandPager(opts []CommandPaginateOption) (*commandPager, error) {
	pager := &commandPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCommandOrder
	}
	return pager, nil
}

func (p *commandPager) applyFilter(query *CommandQuery) (*CommandQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commandPager) toCursor(c *Command) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *commandPager) applyCursors(query *CommandQuery, after, before *Cursor) *CommandQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCommandOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *commandPager) applyOrder(query *CommandQuery, reverse bool) *CommandQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCommandOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCommandOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Command.
func (c *CommandQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommandPaginateOption,
) (*CommandConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommandPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CommandConnection{Edges: []*CommandEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Command
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Command {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Command {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CommandEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CommandEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CommandOrderField defines the ordering field of Command.
type CommandOrderField struct {
	field    string
	toCursor func(*Command) Cursor
}

// CommandOrder defines the ordering of Command.
type CommandOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CommandOrderField `json:"field"`
}

// DefaultCommandOrder is the default ordering of Command.
var DefaultCommandOrder = &CommandOrder{
	Direction: OrderDirectionAsc,
	Field: &CommandOrderField{
		field: command.FieldID,
		toCursor: func(c *Command) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Command into CommandEdge.
func (c *Command) ToEdge(order *CommandOrder) *CommandEdge {
	if order == nil {
		order = DefaultCommandOrder
	}
	return &CommandEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CompetitionEdge is the edge representation of Competition.
type CompetitionEdge struct {
	Node   *Competition `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CompetitionConnection is the connection containing edges to Competition.
type CompetitionConnection struct {
	Edges      []*CompetitionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// CompetitionPaginateOption enables pagination customization.
type CompetitionPaginateOption func(*competitionPager) error

// WithCompetitionOrder configures pagination ordering.
func WithCompetitionOrder(order *CompetitionOrder) CompetitionPaginateOption {
	if order == nil {
		order = DefaultCompetitionOrder
	}
	o := *order
	return func(pager *competitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompetitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompetitionFilter configures pagination filter.
func WithCompetitionFilter(filter func(*CompetitionQuery) (*CompetitionQuery, error)) CompetitionPaginateOption {
	return func(pager *competitionPager) error {
		if filter == nil {
			return errors.New("CompetitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type competitionPager struct {
	order  *CompetitionOrder
	filter func(*CompetitionQuery) (*CompetitionQuery, error)
}

func newCompetitionPager(opts []CompetitionPaginateOption) (*competitionPager, error) {
	pager := &competitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompetitionOrder
	}
	return pager, nil
}

func (p *competitionPager) applyFilter(query *CompetitionQuery) (*CompetitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *competitionPager) toCursor(c *Competition) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *competitionPager) applyCursors(query *CompetitionQuery, after, before *Cursor) *CompetitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCompetitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *competitionPager) applyOrder(query *CompetitionQuery, reverse bool) *CompetitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCompetitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCompetitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Competition.
func (c *CompetitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompetitionPaginateOption,
) (*CompetitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompetitionPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CompetitionConnection{Edges: []*CompetitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Competition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Competition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Competition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CompetitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CompetitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CompetitionOrderField defines the ordering field of Competition.
type CompetitionOrderField struct {
	field    string
	toCursor func(*Competition) Cursor
}

// CompetitionOrder defines the ordering of Competition.
type CompetitionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CompetitionOrderField `json:"field"`
}

// DefaultCompetitionOrder is the default ordering of Competition.
var DefaultCompetitionOrder = &CompetitionOrder{
	Direction: OrderDirectionAsc,
	Field: &CompetitionOrderField{
		field: competition.FieldID,
		toCursor: func(c *Competition) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Competition into CompetitionEdge.
func (c *Competition) ToEdge(order *CompetitionOrder) *CompetitionEdge {
	if order == nil {
		order = DefaultCompetitionOrder
	}
	return &CompetitionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DNSEdge is the edge representation of DNS.
type DNSEdge struct {
	Node   *DNS   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DNSConnection is the connection containing edges to DNS.
type DNSConnection struct {
	Edges      []*DNSEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// DNSPaginateOption enables pagination customization.
type DNSPaginateOption func(*dNSPager) error

// WithDNSOrder configures pagination ordering.
func WithDNSOrder(order *DNSOrder) DNSPaginateOption {
	if order == nil {
		order = DefaultDNSOrder
	}
	o := *order
	return func(pager *dNSPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSFilter configures pagination filter.
func WithDNSFilter(filter func(*DNSQuery) (*DNSQuery, error)) DNSPaginateOption {
	return func(pager *dNSPager) error {
		if filter == nil {
			return errors.New("DNSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dNSPager struct {
	order  *DNSOrder
	filter func(*DNSQuery) (*DNSQuery, error)
}

func newDNSPager(opts []DNSPaginateOption) (*dNSPager, error) {
	pager := &dNSPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSOrder
	}
	return pager, nil
}

func (p *dNSPager) applyFilter(query *DNSQuery) (*DNSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dNSPager) toCursor(d *DNS) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *dNSPager) applyCursors(query *DNSQuery, after, before *Cursor) *DNSQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDNSOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *dNSPager) applyOrder(query *DNSQuery, reverse bool) *DNSQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDNSOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDNSOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DNS.
func (d *DNSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSPaginateOption,
) (*DNSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}

	conn := &DNSConnection{Edges: []*DNSEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := d.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := d.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	d = pager.applyCursors(d, after, before)
	d = pager.applyOrder(d, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		d = d.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		d = d.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := d.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DNS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNS {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DNSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DNSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DNSOrderField defines the ordering field of DNS.
type DNSOrderField struct {
	field    string
	toCursor func(*DNS) Cursor
}

// DNSOrder defines the ordering of DNS.
type DNSOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *DNSOrderField `json:"field"`
}

// DefaultDNSOrder is the default ordering of DNS.
var DefaultDNSOrder = &DNSOrder{
	Direction: OrderDirectionAsc,
	Field: &DNSOrderField{
		field: dns.FieldID,
		toCursor: func(d *DNS) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts DNS into DNSEdge.
func (d *DNS) ToEdge(order *DNSOrder) *DNSEdge {
	if order == nil {
		order = DefaultDNSOrder
	}
	return &DNSEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// DNSRecordEdge is the edge representation of DNSRecord.
type DNSRecordEdge struct {
	Node   *DNSRecord `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// DNSRecordConnection is the connection containing edges to DNSRecord.
type DNSRecordConnection struct {
	Edges      []*DNSRecordEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// DNSRecordPaginateOption enables pagination customization.
type DNSRecordPaginateOption func(*dNSRecordPager) error

// WithDNSRecordOrder configures pagination ordering.
func WithDNSRecordOrder(order *DNSRecordOrder) DNSRecordPaginateOption {
	if order == nil {
		order = DefaultDNSRecordOrder
	}
	o := *order
	return func(pager *dNSRecordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSRecordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSRecordFilter configures pagination filter.
func WithDNSRecordFilter(filter func(*DNSRecordQuery) (*DNSRecordQuery, error)) DNSRecordPaginateOption {
	return func(pager *dNSRecordPager) error {
		if filter == nil {
			return errors.New("DNSRecordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dNSRecordPager struct {
	order  *DNSRecordOrder
	filter func(*DNSRecordQuery) (*DNSRecordQuery, error)
}

func newDNSRecordPager(opts []DNSRecordPaginateOption) (*dNSRecordPager, error) {
	pager := &dNSRecordPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSRecordOrder
	}
	return pager, nil
}

func (p *dNSRecordPager) applyFilter(query *DNSRecordQuery) (*DNSRecordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dNSRecordPager) toCursor(dr *DNSRecord) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *dNSRecordPager) applyCursors(query *DNSRecordQuery, after, before *Cursor) *DNSRecordQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDNSRecordOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *dNSRecordPager) applyOrder(query *DNSRecordQuery, reverse bool) *DNSRecordQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDNSRecordOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDNSRecordOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DNSRecord.
func (dr *DNSRecordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSRecordPaginateOption,
) (*DNSRecordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSRecordPager(opts)
	if err != nil {
		return nil, err
	}

	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}

	conn := &DNSRecordConnection{Edges: []*DNSRecordEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := dr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dr = pager.applyCursors(dr, after, before)
	dr = pager.applyOrder(dr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dr = dr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dr = dr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DNSRecord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSRecord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSRecord {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DNSRecordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DNSRecordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DNSRecordOrderField defines the ordering field of DNSRecord.
type DNSRecordOrderField struct {
	field    string
	toCursor func(*DNSRecord) Cursor
}

// DNSRecordOrder defines the ordering of DNSRecord.
type DNSRecordOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *DNSRecordOrderField `json:"field"`
}

// DefaultDNSRecordOrder is the default ordering of DNSRecord.
var DefaultDNSRecordOrder = &DNSRecordOrder{
	Direction: OrderDirectionAsc,
	Field: &DNSRecordOrderField{
		field: dnsrecord.FieldID,
		toCursor: func(dr *DNSRecord) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DNSRecord into DNSRecordEdge.
func (dr *DNSRecord) ToEdge(order *DNSRecordOrder) *DNSRecordEdge {
	if order == nil {
		order = DefaultDNSRecordOrder
	}
	return &DNSRecordEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DiskEdge is the edge representation of Disk.
type DiskEdge struct {
	Node   *Disk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DiskConnection is the connection containing edges to Disk.
type DiskConnection struct {
	Edges      []*DiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// DiskPaginateOption enables pagination customization.
type DiskPaginateOption func(*diskPager) error

// WithDiskOrder configures pagination ordering.
func WithDiskOrder(order *DiskOrder) DiskPaginateOption {
	if order == nil {
		order = DefaultDiskOrder
	}
	o := *order
	return func(pager *diskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDiskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDiskFilter configures pagination filter.
func WithDiskFilter(filter func(*DiskQuery) (*DiskQuery, error)) DiskPaginateOption {
	return func(pager *diskPager) error {
		if filter == nil {
			return errors.New("DiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type diskPager struct {
	order  *DiskOrder
	filter func(*DiskQuery) (*DiskQuery, error)
}

func newDiskPager(opts []DiskPaginateOption) (*diskPager, error) {
	pager := &diskPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDiskOrder
	}
	return pager, nil
}

func (p *diskPager) applyFilter(query *DiskQuery) (*DiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *diskPager) toCursor(d *Disk) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *diskPager) applyCursors(query *DiskQuery, after, before *Cursor) *DiskQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDiskOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *diskPager) applyOrder(query *DiskQuery, reverse bool) *DiskQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDiskOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDiskOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Disk.
func (d *DiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DiskPaginateOption,
) (*DiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDiskPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}

	conn := &DiskConnection{Edges: []*DiskEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := d.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := d.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	d = pager.applyCursors(d, after, before)
	d = pager.applyOrder(d, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		d = d.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		d = d.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := d.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Disk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Disk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Disk {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DiskOrderField defines the ordering field of Disk.
type DiskOrderField struct {
	field    string
	toCursor func(*Disk) Cursor
}

// DiskOrder defines the ordering of Disk.
type DiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *DiskOrderField `json:"field"`
}

// DefaultDiskOrder is the default ordering of Disk.
var DefaultDiskOrder = &DiskOrder{
	Direction: OrderDirectionAsc,
	Field: &DiskOrderField{
		field: disk.FieldID,
		toCursor: func(d *Disk) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Disk into DiskEdge.
func (d *Disk) ToEdge(order *DiskOrder) *DiskEdge {
	if order == nil {
		order = DefaultDiskOrder
	}
	return &DiskEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// EnvironmentEdge is the edge representation of Environment.
type EnvironmentEdge struct {
	Node   *Environment `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// EnvironmentConnection is the connection containing edges to Environment.
type EnvironmentConnection struct {
	Edges      []*EnvironmentEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// EnvironmentPaginateOption enables pagination customization.
type EnvironmentPaginateOption func(*environmentPager) error

// WithEnvironmentOrder configures pagination ordering.
func WithEnvironmentOrder(order *EnvironmentOrder) EnvironmentPaginateOption {
	if order == nil {
		order = DefaultEnvironmentOrder
	}
	o := *order
	return func(pager *environmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEnvironmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEnvironmentFilter configures pagination filter.
func WithEnvironmentFilter(filter func(*EnvironmentQuery) (*EnvironmentQuery, error)) EnvironmentPaginateOption {
	return func(pager *environmentPager) error {
		if filter == nil {
			return errors.New("EnvironmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type environmentPager struct {
	order  *EnvironmentOrder
	filter func(*EnvironmentQuery) (*EnvironmentQuery, error)
}

func newEnvironmentPager(opts []EnvironmentPaginateOption) (*environmentPager, error) {
	pager := &environmentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEnvironmentOrder
	}
	return pager, nil
}

func (p *environmentPager) applyFilter(query *EnvironmentQuery) (*EnvironmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *environmentPager) toCursor(e *Environment) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *environmentPager) applyCursors(query *EnvironmentQuery, after, before *Cursor) *EnvironmentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEnvironmentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *environmentPager) applyOrder(query *EnvironmentQuery, reverse bool) *EnvironmentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEnvironmentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEnvironmentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Environment.
func (e *EnvironmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EnvironmentPaginateOption,
) (*EnvironmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEnvironmentPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EnvironmentConnection{Edges: []*EnvironmentEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Environment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Environment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Environment {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EnvironmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EnvironmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EnvironmentOrderField defines the ordering field of Environment.
type EnvironmentOrderField struct {
	field    string
	toCursor func(*Environment) Cursor
}

// EnvironmentOrder defines the ordering of Environment.
type EnvironmentOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *EnvironmentOrderField `json:"field"`
}

// DefaultEnvironmentOrder is the default ordering of Environment.
var DefaultEnvironmentOrder = &EnvironmentOrder{
	Direction: OrderDirectionAsc,
	Field: &EnvironmentOrderField{
		field: environment.FieldID,
		toCursor: func(e *Environment) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Environment into EnvironmentEdge.
func (e *Environment) ToEdge(order *EnvironmentOrder) *EnvironmentEdge {
	if order == nil {
		order = DefaultEnvironmentOrder
	}
	return &EnvironmentEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FileDeleteEdge is the edge representation of FileDelete.
type FileDeleteEdge struct {
	Node   *FileDelete `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// FileDeleteConnection is the connection containing edges to FileDelete.
type FileDeleteConnection struct {
	Edges      []*FileDeleteEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// FileDeletePaginateOption enables pagination customization.
type FileDeletePaginateOption func(*fileDeletePager) error

// WithFileDeleteOrder configures pagination ordering.
func WithFileDeleteOrder(order *FileDeleteOrder) FileDeletePaginateOption {
	if order == nil {
		order = DefaultFileDeleteOrder
	}
	o := *order
	return func(pager *fileDeletePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileDeleteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileDeleteFilter configures pagination filter.
func WithFileDeleteFilter(filter func(*FileDeleteQuery) (*FileDeleteQuery, error)) FileDeletePaginateOption {
	return func(pager *fileDeletePager) error {
		if filter == nil {
			return errors.New("FileDeleteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileDeletePager struct {
	order  *FileDeleteOrder
	filter func(*FileDeleteQuery) (*FileDeleteQuery, error)
}

func newFileDeletePager(opts []FileDeletePaginateOption) (*fileDeletePager, error) {
	pager := &fileDeletePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileDeleteOrder
	}
	return pager, nil
}

func (p *fileDeletePager) applyFilter(query *FileDeleteQuery) (*FileDeleteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileDeletePager) toCursor(fd *FileDelete) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *fileDeletePager) applyCursors(query *FileDeleteQuery, after, before *Cursor) *FileDeleteQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileDeleteOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *fileDeletePager) applyOrder(query *FileDeleteQuery, reverse bool) *FileDeleteQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileDeleteOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileDeleteOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FileDelete.
func (fd *FileDeleteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileDeletePaginateOption,
) (*FileDeleteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileDeletePager(opts)
	if err != nil {
		return nil, err
	}

	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}

	conn := &FileDeleteConnection{Edges: []*FileDeleteEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fd = pager.applyCursors(fd, after, before)
	fd = pager.applyOrder(fd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fd = fd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fd = fd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FileDelete
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileDelete {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileDelete {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileDeleteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileDeleteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileDeleteOrderField defines the ordering field of FileDelete.
type FileDeleteOrderField struct {
	field    string
	toCursor func(*FileDelete) Cursor
}

// FileDeleteOrder defines the ordering of FileDelete.
type FileDeleteOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *FileDeleteOrderField `json:"field"`
}

// DefaultFileDeleteOrder is the default ordering of FileDelete.
var DefaultFileDeleteOrder = &FileDeleteOrder{
	Direction: OrderDirectionAsc,
	Field: &FileDeleteOrderField{
		field: filedelete.FieldID,
		toCursor: func(fd *FileDelete) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// ToEdge converts FileDelete into FileDeleteEdge.
func (fd *FileDelete) ToEdge(order *FileDeleteOrder) *FileDeleteEdge {
	if order == nil {
		order = DefaultFileDeleteOrder
	}
	return &FileDeleteEdge{
		Node:   fd,
		Cursor: order.Field.toCursor(fd),
	}
}

// FileDownloadEdge is the edge representation of FileDownload.
type FileDownloadEdge struct {
	Node   *FileDownload `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// FileDownloadConnection is the connection containing edges to FileDownload.
type FileDownloadConnection struct {
	Edges      []*FileDownloadEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// FileDownloadPaginateOption enables pagination customization.
type FileDownloadPaginateOption func(*fileDownloadPager) error

// WithFileDownloadOrder configures pagination ordering.
func WithFileDownloadOrder(order *FileDownloadOrder) FileDownloadPaginateOption {
	if order == nil {
		order = DefaultFileDownloadOrder
	}
	o := *order
	return func(pager *fileDownloadPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileDownloadOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileDownloadFilter configures pagination filter.
func WithFileDownloadFilter(filter func(*FileDownloadQuery) (*FileDownloadQuery, error)) FileDownloadPaginateOption {
	return func(pager *fileDownloadPager) error {
		if filter == nil {
			return errors.New("FileDownloadQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileDownloadPager struct {
	order  *FileDownloadOrder
	filter func(*FileDownloadQuery) (*FileDownloadQuery, error)
}

func newFileDownloadPager(opts []FileDownloadPaginateOption) (*fileDownloadPager, error) {
	pager := &fileDownloadPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileDownloadOrder
	}
	return pager, nil
}

func (p *fileDownloadPager) applyFilter(query *FileDownloadQuery) (*FileDownloadQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileDownloadPager) toCursor(fd *FileDownload) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *fileDownloadPager) applyCursors(query *FileDownloadQuery, after, before *Cursor) *FileDownloadQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileDownloadOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *fileDownloadPager) applyOrder(query *FileDownloadQuery, reverse bool) *FileDownloadQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileDownloadOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileDownloadOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FileDownload.
func (fd *FileDownloadQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileDownloadPaginateOption,
) (*FileDownloadConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileDownloadPager(opts)
	if err != nil {
		return nil, err
	}

	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}

	conn := &FileDownloadConnection{Edges: []*FileDownloadEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fd = pager.applyCursors(fd, after, before)
	fd = pager.applyOrder(fd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fd = fd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fd = fd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FileDownload
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileDownload {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileDownload {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileDownloadEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileDownloadEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileDownloadOrderField defines the ordering field of FileDownload.
type FileDownloadOrderField struct {
	field    string
	toCursor func(*FileDownload) Cursor
}

// FileDownloadOrder defines the ordering of FileDownload.
type FileDownloadOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *FileDownloadOrderField `json:"field"`
}

// DefaultFileDownloadOrder is the default ordering of FileDownload.
var DefaultFileDownloadOrder = &FileDownloadOrder{
	Direction: OrderDirectionAsc,
	Field: &FileDownloadOrderField{
		field: filedownload.FieldID,
		toCursor: func(fd *FileDownload) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// ToEdge converts FileDownload into FileDownloadEdge.
func (fd *FileDownload) ToEdge(order *FileDownloadOrder) *FileDownloadEdge {
	if order == nil {
		order = DefaultFileDownloadOrder
	}
	return &FileDownloadEdge{
		Node:   fd,
		Cursor: order.Field.toCursor(fd),
	}
}

// FileExtractEdge is the edge representation of FileExtract.
type FileExtractEdge struct {
	Node   *FileExtract `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileExtractConnection is the connection containing edges to FileExtract.
type FileExtractConnection struct {
	Edges      []*FileExtractEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// FileExtractPaginateOption enables pagination customization.
type FileExtractPaginateOption func(*fileExtractPager) error

// WithFileExtractOrder configures pagination ordering.
func WithFileExtractOrder(order *FileExtractOrder) FileExtractPaginateOption {
	if order == nil {
		order = DefaultFileExtractOrder
	}
	o := *order
	return func(pager *fileExtractPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileExtractOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileExtractFilter configures pagination filter.
func WithFileExtractFilter(filter func(*FileExtractQuery) (*FileExtractQuery, error)) FileExtractPaginateOption {
	return func(pager *fileExtractPager) error {
		if filter == nil {
			return errors.New("FileExtractQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileExtractPager struct {
	order  *FileExtractOrder
	filter func(*FileExtractQuery) (*FileExtractQuery, error)
}

func newFileExtractPager(opts []FileExtractPaginateOption) (*fileExtractPager, error) {
	pager := &fileExtractPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileExtractOrder
	}
	return pager, nil
}

func (p *fileExtractPager) applyFilter(query *FileExtractQuery) (*FileExtractQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileExtractPager) toCursor(fe *FileExtract) Cursor {
	return p.order.Field.toCursor(fe)
}

func (p *fileExtractPager) applyCursors(query *FileExtractQuery, after, before *Cursor) *FileExtractQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileExtractOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *fileExtractPager) applyOrder(query *FileExtractQuery, reverse bool) *FileExtractQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileExtractOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileExtractOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FileExtract.
func (fe *FileExtractQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileExtractPaginateOption,
) (*FileExtractConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileExtractPager(opts)
	if err != nil {
		return nil, err
	}

	if fe, err = pager.applyFilter(fe); err != nil {
		return nil, err
	}

	conn := &FileExtractConnection{Edges: []*FileExtractEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fe.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fe.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fe = pager.applyCursors(fe, after, before)
	fe = pager.applyOrder(fe, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fe = fe.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fe = fe.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fe.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FileExtract
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileExtract {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileExtract {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileExtractEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileExtractEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileExtractOrderField defines the ordering field of FileExtract.
type FileExtractOrderField struct {
	field    string
	toCursor func(*FileExtract) Cursor
}

// FileExtractOrder defines the ordering of FileExtract.
type FileExtractOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileExtractOrderField `json:"field"`
}

// DefaultFileExtractOrder is the default ordering of FileExtract.
var DefaultFileExtractOrder = &FileExtractOrder{
	Direction: OrderDirectionAsc,
	Field: &FileExtractOrderField{
		field: fileextract.FieldID,
		toCursor: func(fe *FileExtract) Cursor {
			return Cursor{ID: fe.ID}
		},
	},
}

// ToEdge converts FileExtract into FileExtractEdge.
func (fe *FileExtract) ToEdge(order *FileExtractOrder) *FileExtractEdge {
	if order == nil {
		order = DefaultFileExtractOrder
	}
	return &FileExtractEdge{
		Node:   fe,
		Cursor: order.Field.toCursor(fe),
	}
}

// FindingEdge is the edge representation of Finding.
type FindingEdge struct {
	Node   *Finding `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FindingConnection is the connection containing edges to Finding.
type FindingConnection struct {
	Edges      []*FindingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// FindingPaginateOption enables pagination customization.
type FindingPaginateOption func(*findingPager) error

// WithFindingOrder configures pagination ordering.
func WithFindingOrder(order *FindingOrder) FindingPaginateOption {
	if order == nil {
		order = DefaultFindingOrder
	}
	o := *order
	return func(pager *findingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingFilter configures pagination filter.
func WithFindingFilter(filter func(*FindingQuery) (*FindingQuery, error)) FindingPaginateOption {
	return func(pager *findingPager) error {
		if filter == nil {
			return errors.New("FindingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingPager struct {
	order  *FindingOrder
	filter func(*FindingQuery) (*FindingQuery, error)
}

func newFindingPager(opts []FindingPaginateOption) (*findingPager, error) {
	pager := &findingPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingOrder
	}
	return pager, nil
}

func (p *findingPager) applyFilter(query *FindingQuery) (*FindingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingPager) toCursor(f *Finding) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *findingPager) applyCursors(query *FindingQuery, after, before *Cursor) *FindingQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFindingOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *findingPager) applyOrder(query *FindingQuery, reverse bool) *FindingQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFindingOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFindingOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Finding.
func (f *FindingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingPaginateOption,
) (*FindingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingPager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}

	conn := &FindingConnection{Edges: []*FindingEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := f.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := f.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		f = f.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		f = f.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := f.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Finding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Finding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Finding {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FindingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FindingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FindingOrderField defines the ordering field of Finding.
type FindingOrderField struct {
	field    string
	toCursor func(*Finding) Cursor
}

// FindingOrder defines the ordering of Finding.
type FindingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FindingOrderField `json:"field"`
}

// DefaultFindingOrder is the default ordering of Finding.
var DefaultFindingOrder = &FindingOrder{
	Direction: OrderDirectionAsc,
	Field: &FindingOrderField{
		field: finding.FieldID,
		toCursor: func(f *Finding) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Finding into FindingEdge.
func (f *Finding) ToEdge(order *FindingOrder) *FindingEdge {
	if order == nil {
		order = DefaultFindingOrder
	}
	return &FindingEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// HostEdge is the edge representation of Host.
type HostEdge struct {
	Node   *Host  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HostConnection is the connection containing edges to Host.
type HostConnection struct {
	Edges      []*HostEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// HostPaginateOption enables pagination customization.
type HostPaginateOption func(*hostPager) error

// WithHostOrder configures pagination ordering.
func WithHostOrder(order *HostOrder) HostPaginateOption {
	if order == nil {
		order = DefaultHostOrder
	}
	o := *order
	return func(pager *hostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHostFilter configures pagination filter.
func WithHostFilter(filter func(*HostQuery) (*HostQuery, error)) HostPaginateOption {
	return func(pager *hostPager) error {
		if filter == nil {
			return errors.New("HostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hostPager struct {
	order  *HostOrder
	filter func(*HostQuery) (*HostQuery, error)
}

func newHostPager(opts []HostPaginateOption) (*hostPager, error) {
	pager := &hostPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHostOrder
	}
	return pager, nil
}

func (p *hostPager) applyFilter(query *HostQuery) (*HostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hostPager) toCursor(h *Host) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *hostPager) applyCursors(query *HostQuery, after, before *Cursor) *HostQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHostOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hostPager) applyOrder(query *HostQuery, reverse bool) *HostQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHostOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHostOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Host.
func (h *HostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HostPaginateOption,
) (*HostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHostPager(opts)
	if err != nil {
		return nil, err
	}

	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}

	conn := &HostConnection{Edges: []*HostEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := h.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := h.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	h = pager.applyCursors(h, after, before)
	h = pager.applyOrder(h, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		h = h.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		h = h.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := h.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Host
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Host {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Host {
			return nodes[i]
		}
	}

	conn.Edges = make([]*HostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &HostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// HostOrderField defines the ordering field of Host.
type HostOrderField struct {
	field    string
	toCursor func(*Host) Cursor
}

// HostOrder defines the ordering of Host.
type HostOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HostOrderField `json:"field"`
}

// DefaultHostOrder is the default ordering of Host.
var DefaultHostOrder = &HostOrder{
	Direction: OrderDirectionAsc,
	Field: &HostOrderField{
		field: host.FieldID,
		toCursor: func(h *Host) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Host into HostEdge.
func (h *Host) ToEdge(order *HostOrder) *HostEdge {
	if order == nil {
		order = DefaultHostOrder
	}
	return &HostEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// IncludedNetworkEdge is the edge representation of IncludedNetwork.
type IncludedNetworkEdge struct {
	Node   *IncludedNetwork `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// IncludedNetworkConnection is the connection containing edges to IncludedNetwork.
type IncludedNetworkConnection struct {
	Edges      []*IncludedNetworkEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// IncludedNetworkPaginateOption enables pagination customization.
type IncludedNetworkPaginateOption func(*includedNetworkPager) error

// WithIncludedNetworkOrder configures pagination ordering.
func WithIncludedNetworkOrder(order *IncludedNetworkOrder) IncludedNetworkPaginateOption {
	if order == nil {
		order = DefaultIncludedNetworkOrder
	}
	o := *order
	return func(pager *includedNetworkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIncludedNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIncludedNetworkFilter configures pagination filter.
func WithIncludedNetworkFilter(filter func(*IncludedNetworkQuery) (*IncludedNetworkQuery, error)) IncludedNetworkPaginateOption {
	return func(pager *includedNetworkPager) error {
		if filter == nil {
			return errors.New("IncludedNetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type includedNetworkPager struct {
	order  *IncludedNetworkOrder
	filter func(*IncludedNetworkQuery) (*IncludedNetworkQuery, error)
}

func newIncludedNetworkPager(opts []IncludedNetworkPaginateOption) (*includedNetworkPager, error) {
	pager := &includedNetworkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIncludedNetworkOrder
	}
	return pager, nil
}

func (p *includedNetworkPager) applyFilter(query *IncludedNetworkQuery) (*IncludedNetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *includedNetworkPager) toCursor(in *IncludedNetwork) Cursor {
	return p.order.Field.toCursor(in)
}

func (p *includedNetworkPager) applyCursors(query *IncludedNetworkQuery, after, before *Cursor) *IncludedNetworkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultIncludedNetworkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *includedNetworkPager) applyOrder(query *IncludedNetworkQuery, reverse bool) *IncludedNetworkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultIncludedNetworkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultIncludedNetworkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to IncludedNetwork.
func (in *IncludedNetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IncludedNetworkPaginateOption,
) (*IncludedNetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIncludedNetworkPager(opts)
	if err != nil {
		return nil, err
	}

	if in, err = pager.applyFilter(in); err != nil {
		return nil, err
	}

	conn := &IncludedNetworkConnection{Edges: []*IncludedNetworkEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := in.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := in.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	in = pager.applyCursors(in, after, before)
	in = pager.applyOrder(in, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		in = in.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		in = in.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := in.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *IncludedNetwork
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IncludedNetwork {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IncludedNetwork {
			return nodes[i]
		}
	}

	conn.Edges = make([]*IncludedNetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &IncludedNetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// IncludedNetworkOrderField defines the ordering field of IncludedNetwork.
type IncludedNetworkOrderField struct {
	field    string
	toCursor func(*IncludedNetwork) Cursor
}

// IncludedNetworkOrder defines the ordering of IncludedNetwork.
type IncludedNetworkOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *IncludedNetworkOrderField `json:"field"`
}

// DefaultIncludedNetworkOrder is the default ordering of IncludedNetwork.
var DefaultIncludedNetworkOrder = &IncludedNetworkOrder{
	Direction: OrderDirectionAsc,
	Field: &IncludedNetworkOrderField{
		field: includednetwork.FieldID,
		toCursor: func(in *IncludedNetwork) Cursor {
			return Cursor{ID: in.ID}
		},
	},
}

// ToEdge converts IncludedNetwork into IncludedNetworkEdge.
func (in *IncludedNetwork) ToEdge(order *IncludedNetworkOrder) *IncludedNetworkEdge {
	if order == nil {
		order = DefaultIncludedNetworkOrder
	}
	return &IncludedNetworkEdge{
		Node:   in,
		Cursor: order.Field.toCursor(in),
	}
}

// NetworkEdge is the edge representation of Network.
type NetworkEdge struct {
	Node   *Network `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// NetworkConnection is the connection containing edges to Network.
type NetworkConnection struct {
	Edges      []*NetworkEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// NetworkPaginateOption enables pagination customization.
type NetworkPaginateOption func(*networkPager) error

// WithNetworkOrder configures pagination ordering.
func WithNetworkOrder(order *NetworkOrder) NetworkPaginateOption {
	if order == nil {
		order = DefaultNetworkOrder
	}
	o := *order
	return func(pager *networkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNetworkFilter configures pagination filter.
func WithNetworkFilter(filter func(*NetworkQuery) (*NetworkQuery, error)) NetworkPaginateOption {
	return func(pager *networkPager) error {
		if filter == nil {
			return errors.New("NetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type networkPager struct {
	order  *NetworkOrder
	filter func(*NetworkQuery) (*NetworkQuery, error)
}

func newNetworkPager(opts []NetworkPaginateOption) (*networkPager, error) {
	pager := &networkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNetworkOrder
	}
	return pager, nil
}

func (p *networkPager) applyFilter(query *NetworkQuery) (*NetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *networkPager) toCursor(n *Network) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *networkPager) applyCursors(query *NetworkQuery, after, before *Cursor) *NetworkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultNetworkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *networkPager) applyOrder(query *NetworkQuery, reverse bool) *NetworkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultNetworkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultNetworkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Network.
func (n *NetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NetworkPaginateOption,
) (*NetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNetworkPager(opts)
	if err != nil {
		return nil, err
	}

	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}

	conn := &NetworkConnection{Edges: []*NetworkEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := n.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := n.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	n = pager.applyCursors(n, after, before)
	n = pager.applyOrder(n, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		n = n.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		n = n.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := n.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Network
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Network {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Network {
			return nodes[i]
		}
	}

	conn.Edges = make([]*NetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &NetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// NetworkOrderField defines the ordering field of Network.
type NetworkOrderField struct {
	field    string
	toCursor func(*Network) Cursor
}

// NetworkOrder defines the ordering of Network.
type NetworkOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *NetworkOrderField `json:"field"`
}

// DefaultNetworkOrder is the default ordering of Network.
var DefaultNetworkOrder = &NetworkOrder{
	Direction: OrderDirectionAsc,
	Field: &NetworkOrderField{
		field: network.FieldID,
		toCursor: func(n *Network) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Network into NetworkEdge.
func (n *Network) ToEdge(order *NetworkOrder) *NetworkEdge {
	if order == nil {
		order = DefaultNetworkOrder
	}
	return &NetworkEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// ProvisionedHostEdge is the edge representation of ProvisionedHost.
type ProvisionedHostEdge struct {
	Node   *ProvisionedHost `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ProvisionedHostConnection is the connection containing edges to ProvisionedHost.
type ProvisionedHostConnection struct {
	Edges      []*ProvisionedHostEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// ProvisionedHostPaginateOption enables pagination customization.
type ProvisionedHostPaginateOption func(*provisionedHostPager) error

// WithProvisionedHostOrder configures pagination ordering.
func WithProvisionedHostOrder(order *ProvisionedHostOrder) ProvisionedHostPaginateOption {
	if order == nil {
		order = DefaultProvisionedHostOrder
	}
	o := *order
	return func(pager *provisionedHostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisionedHostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisionedHostFilter configures pagination filter.
func WithProvisionedHostFilter(filter func(*ProvisionedHostQuery) (*ProvisionedHostQuery, error)) ProvisionedHostPaginateOption {
	return func(pager *provisionedHostPager) error {
		if filter == nil {
			return errors.New("ProvisionedHostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisionedHostPager struct {
	order  *ProvisionedHostOrder
	filter func(*ProvisionedHostQuery) (*ProvisionedHostQuery, error)
}

func newProvisionedHostPager(opts []ProvisionedHostPaginateOption) (*provisionedHostPager, error) {
	pager := &provisionedHostPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisionedHostOrder
	}
	return pager, nil
}

func (p *provisionedHostPager) applyFilter(query *ProvisionedHostQuery) (*ProvisionedHostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisionedHostPager) toCursor(ph *ProvisionedHost) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *provisionedHostPager) applyCursors(query *ProvisionedHostQuery, after, before *Cursor) *ProvisionedHostQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProvisionedHostOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *provisionedHostPager) applyOrder(query *ProvisionedHostQuery, reverse bool) *ProvisionedHostQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProvisionedHostOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProvisionedHostOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProvisionedHost.
func (ph *ProvisionedHostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisionedHostPaginateOption,
) (*ProvisionedHostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisionedHostPager(opts)
	if err != nil {
		return nil, err
	}

	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}

	conn := &ProvisionedHostConnection{Edges: []*ProvisionedHostEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ph.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ph.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ph = pager.applyCursors(ph, after, before)
	ph = pager.applyOrder(ph, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ph = ph.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ph = ph.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ph.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProvisionedHost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisionedHost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisionedHost {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProvisionedHostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProvisionedHostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProvisionedHostOrderField defines the ordering field of ProvisionedHost.
type ProvisionedHostOrderField struct {
	field    string
	toCursor func(*ProvisionedHost) Cursor
}

// ProvisionedHostOrder defines the ordering of ProvisionedHost.
type ProvisionedHostOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ProvisionedHostOrderField `json:"field"`
}

// DefaultProvisionedHostOrder is the default ordering of ProvisionedHost.
var DefaultProvisionedHostOrder = &ProvisionedHostOrder{
	Direction: OrderDirectionAsc,
	Field: &ProvisionedHostOrderField{
		field: provisionedhost.FieldID,
		toCursor: func(ph *ProvisionedHost) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProvisionedHost into ProvisionedHostEdge.
func (ph *ProvisionedHost) ToEdge(order *ProvisionedHostOrder) *ProvisionedHostEdge {
	if order == nil {
		order = DefaultProvisionedHostOrder
	}
	return &ProvisionedHostEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProvisionedNetworkEdge is the edge representation of ProvisionedNetwork.
type ProvisionedNetworkEdge struct {
	Node   *ProvisionedNetwork `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ProvisionedNetworkConnection is the connection containing edges to ProvisionedNetwork.
type ProvisionedNetworkConnection struct {
	Edges      []*ProvisionedNetworkEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

// ProvisionedNetworkPaginateOption enables pagination customization.
type ProvisionedNetworkPaginateOption func(*provisionedNetworkPager) error

// WithProvisionedNetworkOrder configures pagination ordering.
func WithProvisionedNetworkOrder(order *ProvisionedNetworkOrder) ProvisionedNetworkPaginateOption {
	if order == nil {
		order = DefaultProvisionedNetworkOrder
	}
	o := *order
	return func(pager *provisionedNetworkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisionedNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisionedNetworkFilter configures pagination filter.
func WithProvisionedNetworkFilter(filter func(*ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error)) ProvisionedNetworkPaginateOption {
	return func(pager *provisionedNetworkPager) error {
		if filter == nil {
			return errors.New("ProvisionedNetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisionedNetworkPager struct {
	order  *ProvisionedNetworkOrder
	filter func(*ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error)
}

func newProvisionedNetworkPager(opts []ProvisionedNetworkPaginateOption) (*provisionedNetworkPager, error) {
	pager := &provisionedNetworkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisionedNetworkOrder
	}
	return pager, nil
}

func (p *provisionedNetworkPager) applyFilter(query *ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisionedNetworkPager) toCursor(pn *ProvisionedNetwork) Cursor {
	return p.order.Field.toCursor(pn)
}

func (p *provisionedNetworkPager) applyCursors(query *ProvisionedNetworkQuery, after, before *Cursor) *ProvisionedNetworkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProvisionedNetworkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *provisionedNetworkPager) applyOrder(query *ProvisionedNetworkQuery, reverse bool) *ProvisionedNetworkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProvisionedNetworkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProvisionedNetworkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProvisionedNetwork.
func (pn *ProvisionedNetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisionedNetworkPaginateOption,
) (*ProvisionedNetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisionedNetworkPager(opts)
	if err != nil {
		return nil, err
	}

	if pn, err = pager.applyFilter(pn); err != nil {
		return nil, err
	}

	conn := &ProvisionedNetworkConnection{Edges: []*ProvisionedNetworkEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pn.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pn.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pn = pager.applyCursors(pn, after, before)
	pn = pager.applyOrder(pn, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pn = pn.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pn = pn.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pn.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProvisionedNetwork
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisionedNetwork {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisionedNetwork {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProvisionedNetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProvisionedNetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProvisionedNetworkOrderField defines the ordering field of ProvisionedNetwork.
type ProvisionedNetworkOrderField struct {
	field    string
	toCursor func(*ProvisionedNetwork) Cursor
}

// ProvisionedNetworkOrder defines the ordering of ProvisionedNetwork.
type ProvisionedNetworkOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ProvisionedNetworkOrderField `json:"field"`
}

// DefaultProvisionedNetworkOrder is the default ordering of ProvisionedNetwork.
var DefaultProvisionedNetworkOrder = &ProvisionedNetworkOrder{
	Direction: OrderDirectionAsc,
	Field: &ProvisionedNetworkOrderField{
		field: provisionednetwork.FieldID,
		toCursor: func(pn *ProvisionedNetwork) Cursor {
			return Cursor{ID: pn.ID}
		},
	},
}

// ToEdge converts ProvisionedNetwork into ProvisionedNetworkEdge.
func (pn *ProvisionedNetwork) ToEdge(order *ProvisionedNetworkOrder) *ProvisionedNetworkEdge {
	if order == nil {
		order = DefaultProvisionedNetworkOrder
	}
	return &ProvisionedNetworkEdge{
		Node:   pn,
		Cursor: order.Field.toCursor(pn),
	}
}

// ProvisioningStepEdge is the edge representation of ProvisioningStep.
type ProvisioningStepEdge struct {
	Node   *ProvisioningStep `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProvisioningStepConnection is the connection containing edges to ProvisioningStep.
type ProvisioningStepConnection struct {
	Edges      []*ProvisioningStepEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// ProvisioningStepPaginateOption enables pagination customization.
type ProvisioningStepPaginateOption func(*provisioningStepPager) error

// WithProvisioningStepOrder configures pagination ordering.
func WithProvisioningStepOrder(order *ProvisioningStepOrder) ProvisioningStepPaginateOption {
	if order == nil {
		order = DefaultProvisioningStepOrder
	}
	o := *order
	return func(pager *provisioningStepPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisioningStepOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisioningStepFilter configures pagination filter.
func WithProvisioningStepFilter(filter func(*ProvisioningStepQuery) (*ProvisioningStepQuery, error)) ProvisioningStepPaginateOption {
	return func(pager *provisioningStepPager) error {
		if filter == nil {
			return errors.New("ProvisioningStepQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisioningStepPager struct {
	order  *ProvisioningStepOrder
	filter func(*ProvisioningStepQuery) (*ProvisioningStepQuery, error)
}

func newProvisioningStepPager(opts []ProvisioningStepPaginateOption) (*provisioningStepPager, error) {
	pager := &provisioningStepPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisioningStepOrder
	}
	return pager, nil
}

func (p *provisioningStepPager) applyFilter(query *ProvisioningStepQuery) (*ProvisioningStepQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisioningStepPager) toCursor(ps *ProvisioningStep) Cursor {
	return p.order.Field.toCursor(ps)
}

func (p *provisioningStepPager) applyCursors(query *ProvisioningStepQuery, after, before *Cursor) *ProvisioningStepQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProvisioningStepOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *provisioningStepPager) applyOrder(query *ProvisioningStepQuery, reverse bool) *ProvisioningStepQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProvisioningStepOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProvisioningStepOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProvisioningStep.
func (ps *ProvisioningStepQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisioningStepPaginateOption,
) (*ProvisioningStepConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisioningStepPager(opts)
	if err != nil {
		return nil, err
	}

	if ps, err = pager.applyFilter(ps); err != nil {
		return nil, err
	}

	conn := &ProvisioningStepConnection{Edges: []*ProvisioningStepEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ps.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ps.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ps = pager.applyCursors(ps, after, before)
	ps = pager.applyOrder(ps, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ps = ps.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ps = ps.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ps.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProvisioningStep
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisioningStep {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisioningStep {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProvisioningStepEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProvisioningStepEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProvisioningStepOrderField defines the ordering field of ProvisioningStep.
type ProvisioningStepOrderField struct {
	field    string
	toCursor func(*ProvisioningStep) Cursor
}

// ProvisioningStepOrder defines the ordering of ProvisioningStep.
type ProvisioningStepOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProvisioningStepOrderField `json:"field"`
}

// DefaultProvisioningStepOrder is the default ordering of ProvisioningStep.
var DefaultProvisioningStepOrder = &ProvisioningStepOrder{
	Direction: OrderDirectionAsc,
	Field: &ProvisioningStepOrderField{
		field: provisioningstep.FieldID,
		toCursor: func(ps *ProvisioningStep) Cursor {
			return Cursor{ID: ps.ID}
		},
	},
}

// ToEdge converts ProvisioningStep into ProvisioningStepEdge.
func (ps *ProvisioningStep) ToEdge(order *ProvisioningStepOrder) *ProvisioningStepEdge {
	if order == nil {
		order = DefaultProvisioningStepOrder
	}
	return &ProvisioningStepEdge{
		Node:   ps,
		Cursor: order.Field.toCursor(ps),
	}
}

// RemoteFileEdge is the edge representation of RemoteFile.
type RemoteFileEdge struct {
	Node   *RemoteFile `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// RemoteFileConnection is the connection containing edges to RemoteFile.
type RemoteFileConnection struct {
	Edges      []*RemoteFileEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// RemoteFilePaginateOption enables pagination customization.
type RemoteFilePaginateOption func(*remoteFilePager) error

// WithRemoteFileOrder configures pagination ordering.
func WithRemoteFileOrder(order *RemoteFileOrder) RemoteFilePaginateOption {
	if order == nil {
		order = DefaultRemoteFileOrder
	}
	o := *order
	return func(pager *remoteFilePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRemoteFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRemoteFileFilter configures pagination filter.
func WithRemoteFileFilter(filter func(*RemoteFileQuery) (*RemoteFileQuery, error)) RemoteFilePaginateOption {
	return func(pager *remoteFilePager) error {
		if filter == nil {
			return errors.New("RemoteFileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type remoteFilePager struct {
	order  *RemoteFileOrder
	filter func(*RemoteFileQuery) (*RemoteFileQuery, error)
}

func newRemoteFilePager(opts []RemoteFilePaginateOption) (*remoteFilePager, error) {
	pager := &remoteFilePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRemoteFileOrder
	}
	return pager, nil
}

func (p *remoteFilePager) applyFilter(query *RemoteFileQuery) (*RemoteFileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *remoteFilePager) toCursor(rf *RemoteFile) Cursor {
	return p.order.Field.toCursor(rf)
}

func (p *remoteFilePager) applyCursors(query *RemoteFileQuery, after, before *Cursor) *RemoteFileQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRemoteFileOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *remoteFilePager) applyOrder(query *RemoteFileQuery, reverse bool) *RemoteFileQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRemoteFileOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRemoteFileOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to RemoteFile.
func (rf *RemoteFileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RemoteFilePaginateOption,
) (*RemoteFileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRemoteFilePager(opts)
	if err != nil {
		return nil, err
	}

	if rf, err = pager.applyFilter(rf); err != nil {
		return nil, err
	}

	conn := &RemoteFileConnection{Edges: []*RemoteFileEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rf.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := rf.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rf = pager.applyCursors(rf, after, before)
	rf = pager.applyOrder(rf, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rf = rf.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rf = rf.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rf.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *RemoteFile
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RemoteFile {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RemoteFile {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RemoteFileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RemoteFileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// RemoteFileOrderField defines the ordering field of RemoteFile.
type RemoteFileOrderField struct {
	field    string
	toCursor func(*RemoteFile) Cursor
}

// RemoteFileOrder defines the ordering of RemoteFile.
type RemoteFileOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *RemoteFileOrderField `json:"field"`
}

// DefaultRemoteFileOrder is the default ordering of RemoteFile.
var DefaultRemoteFileOrder = &RemoteFileOrder{
	Direction: OrderDirectionAsc,
	Field: &RemoteFileOrderField{
		field: remotefile.FieldID,
		toCursor: func(rf *RemoteFile) Cursor {
			return Cursor{ID: rf.ID}
		},
	},
}

// ToEdge converts RemoteFile into RemoteFileEdge.
func (rf *RemoteFile) ToEdge(order *RemoteFileOrder) *RemoteFileEdge {
	if order == nil {
		order = DefaultRemoteFileOrder
	}
	return &RemoteFileEdge{
		Node:   rf,
		Cursor: order.Field.toCursor(rf),
	}
}

// ScriptEdge is the edge representation of Script.
type ScriptEdge struct {
	Node   *Script `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ScriptConnection is the connection containing edges to Script.
type ScriptConnection struct {
	Edges      []*ScriptEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// ScriptPaginateOption enables pagination customization.
type ScriptPaginateOption func(*scriptPager) error

// WithScriptOrder configures pagination ordering.
func WithScriptOrder(order *ScriptOrder) ScriptPaginateOption {
	if order == nil {
		order = DefaultScriptOrder
	}
	o := *order
	return func(pager *scriptPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScriptOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScriptFilter configures pagination filter.
func WithScriptFilter(filter func(*ScriptQuery) (*ScriptQuery, error)) ScriptPaginateOption {
	return func(pager *scriptPager) error {
		if filter == nil {
			return errors.New("ScriptQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scriptPager struct {
	order  *ScriptOrder
	filter func(*ScriptQuery) (*ScriptQuery, error)
}

func newScriptPager(opts []ScriptPaginateOption) (*scriptPager, error) {
	pager := &scriptPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScriptOrder
	}
	return pager, nil
}

func (p *scriptPager) applyFilter(query *ScriptQuery) (*ScriptQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scriptPager) toCursor(s *Script) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *scriptPager) applyCursors(query *ScriptQuery, after, before *Cursor) *ScriptQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultScriptOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *scriptPager) applyOrder(query *ScriptQuery, reverse bool) *ScriptQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultScriptOrder.Field {
		query = query.Order(direction.orderFunc(DefaultScriptOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Script.
func (s *ScriptQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScriptPaginateOption,
) (*ScriptConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScriptPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &ScriptConnection{Edges: []*ScriptEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Script
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Script {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Script {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ScriptEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ScriptEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ScriptOrderField defines the ordering field of Script.
type ScriptOrderField struct {
	field    string
	toCursor func(*Script) Cursor
}

// ScriptOrder defines the ordering of Script.
type ScriptOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ScriptOrderField `json:"field"`
}

// DefaultScriptOrder is the default ordering of Script.
var DefaultScriptOrder = &ScriptOrder{
	Direction: OrderDirectionAsc,
	Field: &ScriptOrderField{
		field: script.FieldID,
		toCursor: func(s *Script) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Script into ScriptEdge.
func (s *Script) ToEdge(order *ScriptOrder) *ScriptEdge {
	if order == nil {
		order = DefaultScriptOrder
	}
	return &ScriptEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// StatusEdge is the edge representation of Status.
type StatusEdge struct {
	Node   *Status `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// StatusConnection is the connection containing edges to Status.
type StatusConnection struct {
	Edges      []*StatusEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// StatusPaginateOption enables pagination customization.
type StatusPaginateOption func(*statusPager) error

// WithStatusOrder configures pagination ordering.
func WithStatusOrder(order *StatusOrder) StatusPaginateOption {
	if order == nil {
		order = DefaultStatusOrder
	}
	o := *order
	return func(pager *statusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatusFilter configures pagination filter.
func WithStatusFilter(filter func(*StatusQuery) (*StatusQuery, error)) StatusPaginateOption {
	return func(pager *statusPager) error {
		if filter == nil {
			return errors.New("StatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statusPager struct {
	order  *StatusOrder
	filter func(*StatusQuery) (*StatusQuery, error)
}

func newStatusPager(opts []StatusPaginateOption) (*statusPager, error) {
	pager := &statusPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatusOrder
	}
	return pager, nil
}

func (p *statusPager) applyFilter(query *StatusQuery) (*StatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statusPager) toCursor(s *Status) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statusPager) applyCursors(query *StatusQuery, after, before *Cursor) *StatusQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultStatusOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *statusPager) applyOrder(query *StatusQuery, reverse bool) *StatusQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultStatusOrder.Field {
		query = query.Order(direction.orderFunc(DefaultStatusOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Status.
func (s *StatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatusPaginateOption,
) (*StatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatusPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &StatusConnection{Edges: []*StatusEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Status
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Status {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Status {
			return nodes[i]
		}
	}

	conn.Edges = make([]*StatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &StatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// StatusOrderField defines the ordering field of Status.
type StatusOrderField struct {
	field    string
	toCursor func(*Status) Cursor
}

// StatusOrder defines the ordering of Status.
type StatusOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *StatusOrderField `json:"field"`
}

// DefaultStatusOrder is the default ordering of Status.
var DefaultStatusOrder = &StatusOrder{
	Direction: OrderDirectionAsc,
	Field: &StatusOrderField{
		field: status.FieldID,
		toCursor: func(s *Status) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Status into StatusEdge.
func (s *Status) ToEdge(order *StatusOrder) *StatusEdge {
	if order == nil {
		order = DefaultStatusOrder
	}
	return &StatusEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TagEdge is the edge representation of Tag.
type TagEdge struct {
	Node   *Tag   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TagConnection is the connection containing edges to Tag.
type TagConnection struct {
	Edges      []*TagEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*tagPager) error

// WithTagOrder configures pagination ordering.
func WithTagOrder(order *TagOrder) TagPaginateOption {
	if order == nil {
		order = DefaultTagOrder
	}
	o := *order
	return func(pager *tagPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTagOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTagFilter configures pagination filter.
func WithTagFilter(filter func(*TagQuery) (*TagQuery, error)) TagPaginateOption {
	return func(pager *tagPager) error {
		if filter == nil {
			return errors.New("TagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagPager struct {
	order  *TagOrder
	filter func(*TagQuery) (*TagQuery, error)
}

func newTagPager(opts []TagPaginateOption) (*tagPager, error) {
	pager := &tagPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTagOrder
	}
	return pager, nil
}

func (p *tagPager) applyFilter(query *TagQuery) (*TagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagPager) toCursor(t *Tag) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tagPager) applyCursors(query *TagQuery, after, before *Cursor) *TagQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTagOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *tagPager) applyOrder(query *TagQuery, reverse bool) *TagQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTagOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTagOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Tag.
func (t *TagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagPaginateOption,
) (*TagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TagConnection{Edges: []*TagEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Tag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tag {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TagOrderField defines the ordering field of Tag.
type TagOrderField struct {
	field    string
	toCursor func(*Tag) Cursor
}

// TagOrder defines the ordering of Tag.
type TagOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *TagOrderField `json:"field"`
}

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = &TagOrder{
	Direction: OrderDirectionAsc,
	Field: &TagOrderField{
		field: tag.FieldID,
		toCursor: func(t *Tag) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tag into TagEdge.
func (t *Tag) ToEdge(order *TagOrder) *TagEdge {
	if order == nil {
		order = DefaultTagOrder
	}
	return &TagEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TeamEdge is the edge representation of Team.
type TeamEdge struct {
	Node   *Team  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TeamConnection is the connection containing edges to Team.
type TeamConnection struct {
	Edges      []*TeamEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// TeamPaginateOption enables pagination customization.
type TeamPaginateOption func(*teamPager) error

// WithTeamOrder configures pagination ordering.
func WithTeamOrder(order *TeamOrder) TeamPaginateOption {
	if order == nil {
		order = DefaultTeamOrder
	}
	o := *order
	return func(pager *teamPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTeamOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTeamFilter configures pagination filter.
func WithTeamFilter(filter func(*TeamQuery) (*TeamQuery, error)) TeamPaginateOption {
	return func(pager *teamPager) error {
		if filter == nil {
			return errors.New("TeamQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type teamPager struct {
	order  *TeamOrder
	filter func(*TeamQuery) (*TeamQuery, error)
}

func newTeamPager(opts []TeamPaginateOption) (*teamPager, error) {
	pager := &teamPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTeamOrder
	}
	return pager, nil
}

func (p *teamPager) applyFilter(query *TeamQuery) (*TeamQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *teamPager) toCursor(t *Team) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *teamPager) applyCursors(query *TeamQuery, after, before *Cursor) *TeamQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTeamOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *teamPager) applyOrder(query *TeamQuery, reverse bool) *TeamQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTeamOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTeamOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Team.
func (t *TeamQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TeamPaginateOption,
) (*TeamConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTeamPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TeamConnection{Edges: []*TeamEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Team
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Team {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Team {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TeamEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TeamEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TeamOrderField defines the ordering field of Team.
type TeamOrderField struct {
	field    string
	toCursor func(*Team) Cursor
}

// TeamOrder defines the ordering of Team.
type TeamOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TeamOrderField `json:"field"`
}

// DefaultTeamOrder is the default ordering of Team.
var DefaultTeamOrder = &TeamOrder{
	Direction: OrderDirectionAsc,
	Field: &TeamOrderField{
		field: team.FieldID,
		toCursor: func(t *Team) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Team into TeamEdge.
func (t *Team) ToEdge(order *TeamOrder) *TeamEdge {
	if order == nil {
		order = DefaultTeamOrder
	}
	return &TeamEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}

	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := u.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := u.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		u = u.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		u = u.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := u.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
