// Code generated by entc, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/facebook/ent/dialect/sql"
	"github.com/gen0cide/laforge/ent/host"
)

// Host is the model entity for the Host schema.
type Host struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Hostname holds the value of the "hostname" field.
	Hostname string `json:"hostname,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// OS holds the value of the "OS" field.
	OS string `json:"OS,omitempty"`
	// LastOctet holds the value of the "last_octet" field.
	LastOctet int `json:"last_octet,omitempty"`
	// AllowMACChanges holds the value of the "allow_mac_changes" field.
	AllowMACChanges bool `json:"allow_mac_changes,omitempty"`
	// ExposedTCPPorts holds the value of the "exposed_tcp_ports" field.
	ExposedTCPPorts []string `json:"exposed_tcp_ports,omitempty"`
	// ExposedUDPPorts holds the value of the "exposed_udp_ports" field.
	ExposedUDPPorts []string `json:"exposed_udp_ports,omitempty"`
	// OverridePassword holds the value of the "override_password" field.
	OverridePassword string `json:"override_password,omitempty"`
	// Vars holds the value of the "vars" field.
	Vars map[string]string `json:"vars,omitempty"`
	// UserGroups holds the value of the "user_groups" field.
	UserGroups []string `json:"user_groups,omitempty"`
	// DependsOn holds the value of the "depends_on" field.
	DependsOn []string `json:"depends_on,omitempty"`
	// Scripts holds the value of the "scripts" field.
	Scripts []string `json:"scripts,omitempty"`
	// Commands holds the value of the "commands" field.
	Commands []string `json:"commands,omitempty"`
	// RemoteFiles holds the value of the "remote_files" field.
	RemoteFiles []string `json:"remote_files,omitempty"`
	// DNSRecords holds the value of the "dns_records" field.
	DNSRecords []string `json:"dns_records,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the HostQuery when eager-loading is set.
	Edges                 HostEdges `json:"edges"`
	environment_host      *int
	finding_host          *int
	provisioned_host_host *int
}

// HostEdges holds the relations/edges for other nodes in the graph.
type HostEdges struct {
	// Disk holds the value of the disk edge.
	Disk []*Disk
	// Maintainer holds the value of the maintainer edge.
	Maintainer []*User
	// Tag holds the value of the tag edge.
	Tag []*Tag
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// DiskOrErr returns the Disk value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) DiskOrErr() ([]*Disk, error) {
	if e.loadedTypes[0] {
		return e.Disk, nil
	}
	return nil, &NotLoadedError{edge: "disk"}
}

// MaintainerOrErr returns the Maintainer value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) MaintainerOrErr() ([]*User, error) {
	if e.loadedTypes[1] {
		return e.Maintainer, nil
	}
	return nil, &NotLoadedError{edge: "maintainer"}
}

// TagOrErr returns the Tag value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) TagOrErr() ([]*Tag, error) {
	if e.loadedTypes[2] {
		return e.Tag, nil
	}
	return nil, &NotLoadedError{edge: "tag"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Host) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{},  // id
		&sql.NullString{}, // hostname
		&sql.NullString{}, // description
		&sql.NullString{}, // OS
		&sql.NullInt64{},  // last_octet
		&sql.NullBool{},   // allow_mac_changes
		&[]byte{},         // exposed_tcp_ports
		&[]byte{},         // exposed_udp_ports
		&sql.NullString{}, // override_password
		&[]byte{},         // vars
		&[]byte{},         // user_groups
		&[]byte{},         // depends_on
		&[]byte{},         // scripts
		&[]byte{},         // commands
		&[]byte{},         // remote_files
		&[]byte{},         // dns_records
	}
}

// fkValues returns the types for scanning foreign-keys values from sql.Rows.
func (*Host) fkValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{}, // environment_host
		&sql.NullInt64{}, // finding_host
		&sql.NullInt64{}, // provisioned_host_host
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Host fields.
func (h *Host) assignValues(values ...interface{}) error {
	if m, n := len(values), len(host.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	h.ID = int(value.Int64)
	values = values[1:]
	if value, ok := values[0].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field hostname", values[0])
	} else if value.Valid {
		h.Hostname = value.String
	}
	if value, ok := values[1].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field description", values[1])
	} else if value.Valid {
		h.Description = value.String
	}
	if value, ok := values[2].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field OS", values[2])
	} else if value.Valid {
		h.OS = value.String
	}
	if value, ok := values[3].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field last_octet", values[3])
	} else if value.Valid {
		h.LastOctet = int(value.Int64)
	}
	if value, ok := values[4].(*sql.NullBool); !ok {
		return fmt.Errorf("unexpected type %T for field allow_mac_changes", values[4])
	} else if value.Valid {
		h.AllowMACChanges = value.Bool
	}

	if value, ok := values[5].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field exposed_tcp_ports", values[5])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.ExposedTCPPorts); err != nil {
			return fmt.Errorf("unmarshal field exposed_tcp_ports: %v", err)
		}
	}

	if value, ok := values[6].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field exposed_udp_ports", values[6])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.ExposedUDPPorts); err != nil {
			return fmt.Errorf("unmarshal field exposed_udp_ports: %v", err)
		}
	}
	if value, ok := values[7].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field override_password", values[7])
	} else if value.Valid {
		h.OverridePassword = value.String
	}

	if value, ok := values[8].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field vars", values[8])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.Vars); err != nil {
			return fmt.Errorf("unmarshal field vars: %v", err)
		}
	}

	if value, ok := values[9].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field user_groups", values[9])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.UserGroups); err != nil {
			return fmt.Errorf("unmarshal field user_groups: %v", err)
		}
	}

	if value, ok := values[10].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field depends_on", values[10])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.DependsOn); err != nil {
			return fmt.Errorf("unmarshal field depends_on: %v", err)
		}
	}

	if value, ok := values[11].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field scripts", values[11])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.Scripts); err != nil {
			return fmt.Errorf("unmarshal field scripts: %v", err)
		}
	}

	if value, ok := values[12].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field commands", values[12])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.Commands); err != nil {
			return fmt.Errorf("unmarshal field commands: %v", err)
		}
	}

	if value, ok := values[13].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field remote_files", values[13])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.RemoteFiles); err != nil {
			return fmt.Errorf("unmarshal field remote_files: %v", err)
		}
	}

	if value, ok := values[14].(*[]byte); !ok {
		return fmt.Errorf("unexpected type %T for field dns_records", values[14])
	} else if value != nil && len(*value) > 0 {
		if err := json.Unmarshal(*value, &h.DNSRecords); err != nil {
			return fmt.Errorf("unmarshal field dns_records: %v", err)
		}
	}
	values = values[15:]
	if len(values) == len(host.ForeignKeys) {
		if value, ok := values[0].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field environment_host", value)
		} else if value.Valid {
			h.environment_host = new(int)
			*h.environment_host = int(value.Int64)
		}
		if value, ok := values[1].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field finding_host", value)
		} else if value.Valid {
			h.finding_host = new(int)
			*h.finding_host = int(value.Int64)
		}
		if value, ok := values[2].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field provisioned_host_host", value)
		} else if value.Valid {
			h.provisioned_host_host = new(int)
			*h.provisioned_host_host = int(value.Int64)
		}
	}
	return nil
}

// QueryDisk queries the disk edge of the Host.
func (h *Host) QueryDisk() *DiskQuery {
	return (&HostClient{config: h.config}).QueryDisk(h)
}

// QueryMaintainer queries the maintainer edge of the Host.
func (h *Host) QueryMaintainer() *UserQuery {
	return (&HostClient{config: h.config}).QueryMaintainer(h)
}

// QueryTag queries the tag edge of the Host.
func (h *Host) QueryTag() *TagQuery {
	return (&HostClient{config: h.config}).QueryTag(h)
}

// Update returns a builder for updating this Host.
// Note that, you need to call Host.Unwrap() before calling this method, if this Host
// was returned from a transaction, and the transaction was committed or rolled back.
func (h *Host) Update() *HostUpdateOne {
	return (&HostClient{config: h.config}).UpdateOne(h)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (h *Host) Unwrap() *Host {
	tx, ok := h.config.driver.(*txDriver)
	if !ok {
		panic("ent: Host is not a transactional entity")
	}
	h.config.driver = tx.drv
	return h
}

// String implements the fmt.Stringer.
func (h *Host) String() string {
	var builder strings.Builder
	builder.WriteString("Host(")
	builder.WriteString(fmt.Sprintf("id=%v", h.ID))
	builder.WriteString(", hostname=")
	builder.WriteString(h.Hostname)
	builder.WriteString(", description=")
	builder.WriteString(h.Description)
	builder.WriteString(", OS=")
	builder.WriteString(h.OS)
	builder.WriteString(", last_octet=")
	builder.WriteString(fmt.Sprintf("%v", h.LastOctet))
	builder.WriteString(", allow_mac_changes=")
	builder.WriteString(fmt.Sprintf("%v", h.AllowMACChanges))
	builder.WriteString(", exposed_tcp_ports=")
	builder.WriteString(fmt.Sprintf("%v", h.ExposedTCPPorts))
	builder.WriteString(", exposed_udp_ports=")
	builder.WriteString(fmt.Sprintf("%v", h.ExposedUDPPorts))
	builder.WriteString(", override_password=")
	builder.WriteString(h.OverridePassword)
	builder.WriteString(", vars=")
	builder.WriteString(fmt.Sprintf("%v", h.Vars))
	builder.WriteString(", user_groups=")
	builder.WriteString(fmt.Sprintf("%v", h.UserGroups))
	builder.WriteString(", depends_on=")
	builder.WriteString(fmt.Sprintf("%v", h.DependsOn))
	builder.WriteString(", scripts=")
	builder.WriteString(fmt.Sprintf("%v", h.Scripts))
	builder.WriteString(", commands=")
	builder.WriteString(fmt.Sprintf("%v", h.Commands))
	builder.WriteString(", remote_files=")
	builder.WriteString(fmt.Sprintf("%v", h.RemoteFiles))
	builder.WriteString(", dns_records=")
	builder.WriteString(fmt.Sprintf("%v", h.DNSRecords))
	builder.WriteByte(')')
	return builder.String()
}

// Hosts is a parsable slice of Host.
type Hosts []*Host

func (h Hosts) config(cfg config) {
	for _i := range h {
		h[_i].config = cfg
	}
}
