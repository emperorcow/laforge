// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/predicate"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/remotefile"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/google/uuid"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBuild              = "Build"
	TypeCommand            = "Command"
	TypeCompetition        = "Competition"
	TypeDNS                = "DNS"
	TypeDNSRecord          = "DNSRecord"
	TypeDisk               = "Disk"
	TypeEnvironment        = "Environment"
	TypeFileDelete         = "FileDelete"
	TypeFileDownload       = "FileDownload"
	TypeFileExtract        = "FileExtract"
	TypeFinding            = "Finding"
	TypeHost               = "Host"
	TypeIncludedNetwork    = "IncludedNetwork"
	TypeNetwork            = "Network"
	TypeProvisionedHost    = "ProvisionedHost"
	TypeProvisionedNetwork = "ProvisionedNetwork"
	TypeProvisioningStep   = "ProvisioningStep"
	TypeRemoteFile         = "RemoteFile"
	TypeScript             = "Script"
	TypeStatus             = "Status"
	TypeTag                = "Tag"
	TypeTeam               = "Team"
	TypeUser               = "User"
)

// BuildMutation represents an operation that mutate the Builds
// nodes in the graph.
type BuildMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	revision                          *int
	addrevision                       *int
	_config                           *map[string]string
	clearedFields                     map[string]struct{}
	maintainer                        map[int]struct{}
	removedmaintainer                 map[int]struct{}
	clearedmaintainer                 bool
	tag                               map[int]struct{}
	removedtag                        map[int]struct{}
	clearedtag                        bool
	team                              map[int]struct{}
	removedteam                       map[int]struct{}
	clearedteam                       bool
	_ProvisionedNetworkToBuild        map[int]struct{}
	removed_ProvisionedNetworkToBuild map[int]struct{}
	cleared_ProvisionedNetworkToBuild bool
	done                              bool
	oldValue                          func(context.Context) (*Build, error)
	predicates                        []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows to manage the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for Build.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the id field of the mutation.
func withBuildID(id int) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BuildMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRevision sets the revision field.
func (m *BuildMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the revision value in the mutation.
func (m *BuildMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old revision value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to revision.
func (m *BuildMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the revision field in this mutation.
func (m *BuildMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision reset all changes of the "revision" field.
func (m *BuildMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetConfig sets the config field.
func (m *BuildMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the config value in the mutation.
func (m *BuildMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old config value of the Build.
// If the Build object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig reset all changes of the "config" field.
func (m *BuildMutation) ResetConfig() {
	m._config = nil
}

// AddMaintainerIDs adds the maintainer edge to User by ids.
func (m *BuildMutation) AddMaintainerIDs(ids ...int) {
	if m.maintainer == nil {
		m.maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.maintainer[ids[i]] = struct{}{}
	}
}

// ClearMaintainer clears the maintainer edge to User.
func (m *BuildMutation) ClearMaintainer() {
	m.clearedmaintainer = true
}

// MaintainerCleared returns if the edge maintainer was cleared.
func (m *BuildMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// RemoveMaintainerIDs removes the maintainer edge to User by ids.
func (m *BuildMutation) RemoveMaintainerIDs(ids ...int) {
	if m.removedmaintainer == nil {
		m.removedmaintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmaintainer[ids[i]] = struct{}{}
	}
}

// RemovedMaintainer returns the removed ids of maintainer.
func (m *BuildMutation) RemovedMaintainerIDs() (ids []int) {
	for id := range m.removedmaintainer {
		ids = append(ids, id)
	}
	return
}

// MaintainerIDs returns the maintainer ids in the mutation.
func (m *BuildMutation) MaintainerIDs() (ids []int) {
	for id := range m.maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetMaintainer reset all changes of the "maintainer" edge.
func (m *BuildMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
	m.removedmaintainer = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *BuildMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *BuildMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *BuildMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *BuildMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *BuildMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *BuildMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *BuildMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddTeamIDs adds the team edge to Team by ids.
func (m *BuildMutation) AddTeamIDs(ids ...int) {
	if m.team == nil {
		m.team = make(map[int]struct{})
	}
	for i := range ids {
		m.team[ids[i]] = struct{}{}
	}
}

// ClearTeam clears the team edge to Team.
func (m *BuildMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared returns if the edge team was cleared.
func (m *BuildMutation) TeamCleared() bool {
	return m.clearedteam
}

// RemoveTeamIDs removes the team edge to Team by ids.
func (m *BuildMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteam == nil {
		m.removedteam = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteam[ids[i]] = struct{}{}
	}
}

// RemovedTeam returns the removed ids of team.
func (m *BuildMutation) RemovedTeamIDs() (ids []int) {
	for id := range m.removedteam {
		ids = append(ids, id)
	}
	return
}

// TeamIDs returns the team ids in the mutation.
func (m *BuildMutation) TeamIDs() (ids []int) {
	for id := range m.team {
		ids = append(ids, id)
	}
	return
}

// ResetTeam reset all changes of the "team" edge.
func (m *BuildMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
	m.removedteam = nil
}

// AddProvisionedNetworkToBuildIDs adds the ProvisionedNetworkToBuild edge to ProvisionedNetwork by ids.
func (m *BuildMutation) AddProvisionedNetworkToBuildIDs(ids ...int) {
	if m._ProvisionedNetworkToBuild == nil {
		m._ProvisionedNetworkToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToBuild[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToBuild clears the ProvisionedNetworkToBuild edge to ProvisionedNetwork.
func (m *BuildMutation) ClearProvisionedNetworkToBuild() {
	m.cleared_ProvisionedNetworkToBuild = true
}

// ProvisionedNetworkToBuildCleared returns if the edge ProvisionedNetworkToBuild was cleared.
func (m *BuildMutation) ProvisionedNetworkToBuildCleared() bool {
	return m.cleared_ProvisionedNetworkToBuild
}

// RemoveProvisionedNetworkToBuildIDs removes the ProvisionedNetworkToBuild edge to ProvisionedNetwork by ids.
func (m *BuildMutation) RemoveProvisionedNetworkToBuildIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToBuild == nil {
		m.removed_ProvisionedNetworkToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToBuild[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToBuild returns the removed ids of ProvisionedNetworkToBuild.
func (m *BuildMutation) RemovedProvisionedNetworkToBuildIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToBuild {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToBuildIDs returns the ProvisionedNetworkToBuild ids in the mutation.
func (m *BuildMutation) ProvisionedNetworkToBuildIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToBuild {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToBuild reset all changes of the "ProvisionedNetworkToBuild" edge.
func (m *BuildMutation) ResetProvisionedNetworkToBuild() {
	m._ProvisionedNetworkToBuild = nil
	m.cleared_ProvisionedNetworkToBuild = false
	m.removed_ProvisionedNetworkToBuild = nil
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.revision != nil {
		fields = append(fields, build.FieldRevision)
	}
	if m._config != nil {
		fields = append(fields, build.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.Revision()
	case build.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldRevision:
		return m.OldRevision(ctx)
	case build.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case build.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BuildMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, build.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BuildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldRevision:
		m.ResetRevision()
		return nil
	case build.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.maintainer != nil {
		edges = append(edges, build.EdgeMaintainer)
	}
	if m.tag != nil {
		edges = append(edges, build.EdgeTag)
	}
	if m.team != nil {
		edges = append(edges, build.EdgeTeam)
	}
	if m._ProvisionedNetworkToBuild != nil {
		edges = append(edges, build.EdgeProvisionedNetworkToBuild)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.maintainer))
		for id := range m.maintainer {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.team))
		for id := range m.team {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeProvisionedNetworkToBuild:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToBuild))
		for id := range m._ProvisionedNetworkToBuild {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmaintainer != nil {
		edges = append(edges, build.EdgeMaintainer)
	}
	if m.removedtag != nil {
		edges = append(edges, build.EdgeTag)
	}
	if m.removedteam != nil {
		edges = append(edges, build.EdgeTeam)
	}
	if m.removed_ProvisionedNetworkToBuild != nil {
		edges = append(edges, build.EdgeProvisionedNetworkToBuild)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.removedmaintainer))
		for id := range m.removedmaintainer {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.removedteam))
		for id := range m.removedteam {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeProvisionedNetworkToBuild:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToBuild))
		for id := range m.removed_ProvisionedNetworkToBuild {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmaintainer {
		edges = append(edges, build.EdgeMaintainer)
	}
	if m.clearedtag {
		edges = append(edges, build.EdgeTag)
	}
	if m.clearedteam {
		edges = append(edges, build.EdgeTeam)
	}
	if m.cleared_ProvisionedNetworkToBuild {
		edges = append(edges, build.EdgeProvisionedNetworkToBuild)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeMaintainer:
		return m.clearedmaintainer
	case build.EdgeTag:
		return m.clearedtag
	case build.EdgeTeam:
		return m.clearedteam
	case build.EdgeProvisionedNetworkToBuild:
		return m.cleared_ProvisionedNetworkToBuild
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	case build.EdgeTag:
		m.ResetTag()
		return nil
	case build.EdgeTeam:
		m.ResetTeam()
		return nil
	case build.EdgeProvisionedNetworkToBuild:
		m.ResetProvisionedNetworkToBuild()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// CommandMutation represents an operation that mutate the Commands
// nodes in the graph.
type CommandMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	program       *string
	args          *[]string
	ignore_errors *bool
	disabled      *bool
	cooldown      *int
	addcooldown   *int
	timeout       *int
	addtimeout    *int
	vars          *map[string]string
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*Command, error)
	predicates    []predicate.Command
}

var _ ent.Mutation = (*CommandMutation)(nil)

// commandOption allows to manage the mutation configuration using functional options.
type commandOption func(*CommandMutation)

// newCommandMutation creates new mutation for Command.
func newCommandMutation(c config, op Op, opts ...commandOption) *CommandMutation {
	m := &CommandMutation{
		config:        c,
		op:            op,
		typ:           TypeCommand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommandID sets the id field of the mutation.
func withCommandID(id int) commandOption {
	return func(m *CommandMutation) {
		var (
			err   error
			once  sync.Once
			value *Command
		)
		m.oldValue = func(ctx context.Context) (*Command, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Command.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommand sets the old Command of the mutation.
func withCommand(node *Command) commandOption {
	return func(m *CommandMutation) {
		m.oldValue = func(context.Context) (*Command, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CommandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CommandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CommandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CommandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *CommandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *CommandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *CommandMutation) ResetDescription() {
	m.description = nil
}

// SetProgram sets the program field.
func (m *CommandMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the program value in the mutation.
func (m *CommandMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old program value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProgram is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram reset all changes of the "program" field.
func (m *CommandMutation) ResetProgram() {
	m.program = nil
}

// SetArgs sets the args field.
func (m *CommandMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the args value in the mutation.
func (m *CommandMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old args value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArgs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs reset all changes of the "args" field.
func (m *CommandMutation) ResetArgs() {
	m.args = nil
}

// SetIgnoreErrors sets the ignore_errors field.
func (m *CommandMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the ignore_errors value in the mutation.
func (m *CommandMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old ignore_errors value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIgnoreErrors is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors reset all changes of the "ignore_errors" field.
func (m *CommandMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetDisabled sets the disabled field.
func (m *CommandMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the disabled value in the mutation.
func (m *CommandMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old disabled value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled reset all changes of the "disabled" field.
func (m *CommandMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCooldown sets the cooldown field.
func (m *CommandMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the cooldown value in the mutation.
func (m *CommandMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old cooldown value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCooldown is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to cooldown.
func (m *CommandMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the cooldown field in this mutation.
func (m *CommandMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown reset all changes of the "cooldown" field.
func (m *CommandMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the timeout field.
func (m *CommandMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the timeout value in the mutation.
func (m *CommandMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old timeout value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to timeout.
func (m *CommandMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the timeout field in this mutation.
func (m *CommandMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout reset all changes of the "timeout" field.
func (m *CommandMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetVars sets the vars field.
func (m *CommandMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the vars value in the mutation.
func (m *CommandMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old vars value of the Command.
// If the Command object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommandMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars reset all changes of the "vars" field.
func (m *CommandMutation) ResetVars() {
	m.vars = nil
}

// AddUserIDs adds the user edge to User by ids.
func (m *CommandMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the user edge to User.
func (m *CommandMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *CommandMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *CommandMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *CommandMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *CommandMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *CommandMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *CommandMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *CommandMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *CommandMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *CommandMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *CommandMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *CommandMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *CommandMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *CommandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Command).
func (m *CommandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CommandMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, command.FieldName)
	}
	if m.description != nil {
		fields = append(fields, command.FieldDescription)
	}
	if m.program != nil {
		fields = append(fields, command.FieldProgram)
	}
	if m.args != nil {
		fields = append(fields, command.FieldArgs)
	}
	if m.ignore_errors != nil {
		fields = append(fields, command.FieldIgnoreErrors)
	}
	if m.disabled != nil {
		fields = append(fields, command.FieldDisabled)
	}
	if m.cooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	if m.vars != nil {
		fields = append(fields, command.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CommandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case command.FieldName:
		return m.Name()
	case command.FieldDescription:
		return m.Description()
	case command.FieldProgram:
		return m.Program()
	case command.FieldArgs:
		return m.Args()
	case command.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case command.FieldDisabled:
		return m.Disabled()
	case command.FieldCooldown:
		return m.Cooldown()
	case command.FieldTimeout:
		return m.Timeout()
	case command.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CommandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case command.FieldName:
		return m.OldName(ctx)
	case command.FieldDescription:
		return m.OldDescription(ctx)
	case command.FieldProgram:
		return m.OldProgram(ctx)
	case command.FieldArgs:
		return m.OldArgs(ctx)
	case command.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case command.FieldDisabled:
		return m.OldDisabled(ctx)
	case command.FieldCooldown:
		return m.OldCooldown(ctx)
	case command.FieldTimeout:
		return m.OldTimeout(ctx)
	case command.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown Command field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CommandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case command.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case command.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case command.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case command.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case command.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case command.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case command.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CommandMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CommandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case command.FieldCooldown:
		return m.AddedCooldown()
	case command.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CommandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Command numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CommandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CommandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Command nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CommandMutation) ResetField(name string) error {
	switch name {
	case command.FieldName:
		m.ResetName()
		return nil
	case command.FieldDescription:
		m.ResetDescription()
		return nil
	case command.FieldProgram:
		m.ResetProgram()
		return nil
	case command.FieldArgs:
		m.ResetArgs()
		return nil
	case command.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case command.FieldDisabled:
		m.ResetDisabled()
		return nil
	case command.FieldCooldown:
		m.ResetCooldown()
		return nil
	case command.FieldTimeout:
		m.ResetTimeout()
		return nil
	case command.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CommandMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, command.EdgeUser)
	}
	if m.tag != nil {
		edges = append(edges, command.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CommandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CommandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, command.EdgeUser)
	}
	if m.removedtag != nil {
		edges = append(edges, command.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CommandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CommandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, command.EdgeUser)
	}
	if m.clearedtag {
		edges = append(edges, command.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CommandMutation) EdgeCleared(name string) bool {
	switch name {
	case command.EdgeUser:
		return m.cleareduser
	case command.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CommandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Command unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CommandMutation) ResetEdge(name string) error {
	switch name {
	case command.EdgeUser:
		m.ResetUser()
		return nil
	case command.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown Command edge %s", name)
}

// CompetitionMutation represents an operation that mutate the Competitions
// nodes in the graph.
type CompetitionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	root_password *string
	_config       *map[string]string
	clearedFields map[string]struct{}
	dns           map[int]struct{}
	removeddns    map[int]struct{}
	cleareddns    bool
	done          bool
	oldValue      func(context.Context) (*Competition, error)
	predicates    []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows to manage the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for Competition.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the id field of the mutation.
func withCompetitionID(id int) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CompetitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRootPassword sets the root_password field.
func (m *CompetitionMutation) SetRootPassword(s string) {
	m.root_password = &s
}

// RootPassword returns the root_password value in the mutation.
func (m *CompetitionMutation) RootPassword() (r string, exists bool) {
	v := m.root_password
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPassword returns the old root_password value of the Competition.
// If the Competition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CompetitionMutation) OldRootPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPassword: %w", err)
	}
	return oldValue.RootPassword, nil
}

// ResetRootPassword reset all changes of the "root_password" field.
func (m *CompetitionMutation) ResetRootPassword() {
	m.root_password = nil
}

// SetConfig sets the config field.
func (m *CompetitionMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the config value in the mutation.
func (m *CompetitionMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old config value of the Competition.
// If the Competition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CompetitionMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig reset all changes of the "config" field.
func (m *CompetitionMutation) ResetConfig() {
	m._config = nil
}

// AddDnIDs adds the dns edge to DNS by ids.
func (m *CompetitionMutation) AddDnIDs(ids ...int) {
	if m.dns == nil {
		m.dns = make(map[int]struct{})
	}
	for i := range ids {
		m.dns[ids[i]] = struct{}{}
	}
}

// ClearDNS clears the dns edge to DNS.
func (m *CompetitionMutation) ClearDNS() {
	m.cleareddns = true
}

// DNSCleared returns if the edge dns was cleared.
func (m *CompetitionMutation) DNSCleared() bool {
	return m.cleareddns
}

// RemoveDnIDs removes the dns edge to DNS by ids.
func (m *CompetitionMutation) RemoveDnIDs(ids ...int) {
	if m.removeddns == nil {
		m.removeddns = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddns[ids[i]] = struct{}{}
	}
}

// RemovedDNS returns the removed ids of dns.
func (m *CompetitionMutation) RemovedDNSIDs() (ids []int) {
	for id := range m.removeddns {
		ids = append(ids, id)
	}
	return
}

// DNSIDs returns the dns ids in the mutation.
func (m *CompetitionMutation) DNSIDs() (ids []int) {
	for id := range m.dns {
		ids = append(ids, id)
	}
	return
}

// ResetDNS reset all changes of the "dns" edge.
func (m *CompetitionMutation) ResetDNS() {
	m.dns = nil
	m.cleareddns = false
	m.removeddns = nil
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.root_password != nil {
		fields = append(fields, competition.FieldRootPassword)
	}
	if m._config != nil {
		fields = append(fields, competition.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldRootPassword:
		return m.RootPassword()
	case competition.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldRootPassword:
		return m.OldRootPassword(ctx)
	case competition.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldRootPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPassword(v)
		return nil
	case competition.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldRootPassword:
		m.ResetRootPassword()
		return nil
	case competition.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dns != nil {
		edges = append(edges, competition.EdgeDNS)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeDNS:
		ids := make([]ent.Value, 0, len(m.dns))
		for id := range m.dns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddns != nil {
		edges = append(edges, competition.EdgeDNS)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeDNS:
		ids := make([]ent.Value, 0, len(m.removeddns))
		for id := range m.removeddns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddns {
		edges = append(edges, competition.EdgeDNS)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeDNS:
		return m.cleareddns
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeDNS:
		m.ResetDNS()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// DNSMutation represents an operation that mutate the DNSs
// nodes in the graph.
type DNSMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *string
	root_domain   *string
	dns_servers   *[]string
	ntp_servers   *[]string
	_config       *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DNS, error)
	predicates    []predicate.DNS
}

var _ ent.Mutation = (*DNSMutation)(nil)

// dnsOption allows to manage the mutation configuration using functional options.
type dnsOption func(*DNSMutation)

// newDNSMutation creates new mutation for DNS.
func newDNSMutation(c config, op Op, opts ...dnsOption) *DNSMutation {
	m := &DNSMutation{
		config:        c,
		op:            op,
		typ:           TypeDNS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSID sets the id field of the mutation.
func withDNSID(id int) dnsOption {
	return func(m *DNSMutation) {
		var (
			err   error
			once  sync.Once
			value *DNS
		)
		m.oldValue = func(ctx context.Context) (*DNS, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNS sets the old DNS of the mutation.
func withDNS(node *DNS) dnsOption {
	return func(m *DNSMutation) {
		m.oldValue = func(context.Context) (*DNS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DNSMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *DNSMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *DNSMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the DNS.
// If the DNS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *DNSMutation) ResetType() {
	m._type = nil
}

// SetRootDomain sets the root_domain field.
func (m *DNSMutation) SetRootDomain(s string) {
	m.root_domain = &s
}

// RootDomain returns the root_domain value in the mutation.
func (m *DNSMutation) RootDomain() (r string, exists bool) {
	v := m.root_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldRootDomain returns the old root_domain value of the DNS.
// If the DNS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSMutation) OldRootDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootDomain is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootDomain: %w", err)
	}
	return oldValue.RootDomain, nil
}

// ResetRootDomain reset all changes of the "root_domain" field.
func (m *DNSMutation) ResetRootDomain() {
	m.root_domain = nil
}

// SetDNSServers sets the dns_servers field.
func (m *DNSMutation) SetDNSServers(s []string) {
	m.dns_servers = &s
}

// DNSServers returns the dns_servers value in the mutation.
func (m *DNSMutation) DNSServers() (r []string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old dns_servers value of the DNS.
// If the DNS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSMutation) OldDNSServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDNSServers is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// ResetDNSServers reset all changes of the "dns_servers" field.
func (m *DNSMutation) ResetDNSServers() {
	m.dns_servers = nil
}

// SetNtpServers sets the ntp_servers field.
func (m *DNSMutation) SetNtpServers(s []string) {
	m.ntp_servers = &s
}

// NtpServers returns the ntp_servers value in the mutation.
func (m *DNSMutation) NtpServers() (r []string, exists bool) {
	v := m.ntp_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldNtpServers returns the old ntp_servers value of the DNS.
// If the DNS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSMutation) OldNtpServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNtpServers is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNtpServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNtpServers: %w", err)
	}
	return oldValue.NtpServers, nil
}

// ResetNtpServers reset all changes of the "ntp_servers" field.
func (m *DNSMutation) ResetNtpServers() {
	m.ntp_servers = nil
}

// SetConfig sets the config field.
func (m *DNSMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the config value in the mutation.
func (m *DNSMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old config value of the DNS.
// If the DNS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig reset all changes of the "config" field.
func (m *DNSMutation) ResetConfig() {
	m._config = nil
}

// Op returns the operation name.
func (m *DNSMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNS).
func (m *DNSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DNSMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, dns.FieldType)
	}
	if m.root_domain != nil {
		fields = append(fields, dns.FieldRootDomain)
	}
	if m.dns_servers != nil {
		fields = append(fields, dns.FieldDNSServers)
	}
	if m.ntp_servers != nil {
		fields = append(fields, dns.FieldNtpServers)
	}
	if m._config != nil {
		fields = append(fields, dns.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DNSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dns.FieldType:
		return m.GetType()
	case dns.FieldRootDomain:
		return m.RootDomain()
	case dns.FieldDNSServers:
		return m.DNSServers()
	case dns.FieldNtpServers:
		return m.NtpServers()
	case dns.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DNSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dns.FieldType:
		return m.OldType(ctx)
	case dns.FieldRootDomain:
		return m.OldRootDomain(ctx)
	case dns.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case dns.FieldNtpServers:
		return m.OldNtpServers(ctx)
	case dns.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown DNS field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DNSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dns.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dns.FieldRootDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootDomain(v)
		return nil
	case dns.FieldDNSServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case dns.FieldNtpServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNtpServers(v)
		return nil
	case dns.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DNSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DNSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DNSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DNSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DNSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNS nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DNSMutation) ResetField(name string) error {
	switch name {
	case dns.FieldType:
		m.ResetType()
		return nil
	case dns.FieldRootDomain:
		m.ResetRootDomain()
		return nil
	case dns.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case dns.FieldNtpServers:
		m.ResetNtpServers()
		return nil
	case dns.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DNSMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DNSMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DNSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DNSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DNSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DNSMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DNSMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DNS unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DNSMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DNS edge %s", name)
}

// DNSRecordMutation represents an operation that mutate the DNSRecords
// nodes in the graph.
type DNSRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	values        *[]string
	_type         *string
	zone          *string
	vars          *map[string]string
	disabled      *bool
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*DNSRecord, error)
	predicates    []predicate.DNSRecord
}

var _ ent.Mutation = (*DNSRecordMutation)(nil)

// dnsrecordOption allows to manage the mutation configuration using functional options.
type dnsrecordOption func(*DNSRecordMutation)

// newDNSRecordMutation creates new mutation for DNSRecord.
func newDNSRecordMutation(c config, op Op, opts ...dnsrecordOption) *DNSRecordMutation {
	m := &DNSRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSRecordID sets the id field of the mutation.
func withDNSRecordID(id int) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSRecord
		)
		m.oldValue = func(ctx context.Context) (*DNSRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSRecord sets the old DNSRecord of the mutation.
func withDNSRecord(node *DNSRecord) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		m.oldValue = func(context.Context) (*DNSRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DNSRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DNSRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DNSRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the DNSRecord.
// If the DNSRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DNSRecordMutation) ResetName() {
	m.name = nil
}

// SetValues sets the values field.
func (m *DNSRecordMutation) SetValues(s []string) {
	m.values = &s
}

// Values returns the values value in the mutation.
func (m *DNSRecordMutation) Values() (r []string, exists bool) {
	v := m.values
	if v == nil {
		return
	}
	return *v, true
}

// OldValues returns the old values value of the DNSRecord.
// If the DNSRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSRecordMutation) OldValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValues is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValues: %w", err)
	}
	return oldValue.Values, nil
}

// ResetValues reset all changes of the "values" field.
func (m *DNSRecordMutation) ResetValues() {
	m.values = nil
}

// SetType sets the type field.
func (m *DNSRecordMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *DNSRecordMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the DNSRecord.
// If the DNSRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSRecordMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *DNSRecordMutation) ResetType() {
	m._type = nil
}

// SetZone sets the zone field.
func (m *DNSRecordMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the zone value in the mutation.
func (m *DNSRecordMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old zone value of the DNSRecord.
// If the DNSRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSRecordMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ResetZone reset all changes of the "zone" field.
func (m *DNSRecordMutation) ResetZone() {
	m.zone = nil
}

// SetVars sets the vars field.
func (m *DNSRecordMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the vars value in the mutation.
func (m *DNSRecordMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old vars value of the DNSRecord.
// If the DNSRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSRecordMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars reset all changes of the "vars" field.
func (m *DNSRecordMutation) ResetVars() {
	m.vars = nil
}

// SetDisabled sets the disabled field.
func (m *DNSRecordMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the disabled value in the mutation.
func (m *DNSRecordMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old disabled value of the DNSRecord.
// If the DNSRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DNSRecordMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled reset all changes of the "disabled" field.
func (m *DNSRecordMutation) ResetDisabled() {
	m.disabled = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *DNSRecordMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *DNSRecordMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *DNSRecordMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *DNSRecordMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *DNSRecordMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *DNSRecordMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *DNSRecordMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *DNSRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSRecord).
func (m *DNSRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DNSRecordMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, dnsrecord.FieldName)
	}
	if m.values != nil {
		fields = append(fields, dnsrecord.FieldValues)
	}
	if m._type != nil {
		fields = append(fields, dnsrecord.FieldType)
	}
	if m.zone != nil {
		fields = append(fields, dnsrecord.FieldZone)
	}
	if m.vars != nil {
		fields = append(fields, dnsrecord.FieldVars)
	}
	if m.disabled != nil {
		fields = append(fields, dnsrecord.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DNSRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsrecord.FieldName:
		return m.Name()
	case dnsrecord.FieldValues:
		return m.Values()
	case dnsrecord.FieldType:
		return m.GetType()
	case dnsrecord.FieldZone:
		return m.Zone()
	case dnsrecord.FieldVars:
		return m.Vars()
	case dnsrecord.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DNSRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsrecord.FieldName:
		return m.OldName(ctx)
	case dnsrecord.FieldValues:
		return m.OldValues(ctx)
	case dnsrecord.FieldType:
		return m.OldType(ctx)
	case dnsrecord.FieldZone:
		return m.OldZone(ctx)
	case dnsrecord.FieldVars:
		return m.OldVars(ctx)
	case dnsrecord.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown DNSRecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DNSRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsrecord.FieldValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValues(v)
		return nil
	case dnsrecord.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dnsrecord.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	case dnsrecord.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case dnsrecord.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DNSRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DNSRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DNSRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DNSRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DNSRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DNSRecordMutation) ResetField(name string) error {
	switch name {
	case dnsrecord.FieldName:
		m.ResetName()
		return nil
	case dnsrecord.FieldValues:
		m.ResetValues()
		return nil
	case dnsrecord.FieldType:
		m.ResetType()
		return nil
	case dnsrecord.FieldZone:
		m.ResetZone()
		return nil
	case dnsrecord.FieldVars:
		m.ResetVars()
		return nil
	case dnsrecord.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DNSRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, dnsrecord.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DNSRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dnsrecord.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DNSRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, dnsrecord.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DNSRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dnsrecord.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DNSRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, dnsrecord.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DNSRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case dnsrecord.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DNSRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSRecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DNSRecordMutation) ResetEdge(name string) error {
	switch name {
	case dnsrecord.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord edge %s", name)
}

// DiskMutation represents an operation that mutate the Disks
// nodes in the graph.
type DiskMutation struct {
	config
	op            Op
	typ           string
	id            *int
	size          *int
	addsize       *int
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*Disk, error)
	predicates    []predicate.Disk
}

var _ ent.Mutation = (*DiskMutation)(nil)

// diskOption allows to manage the mutation configuration using functional options.
type diskOption func(*DiskMutation)

// newDiskMutation creates new mutation for Disk.
func newDiskMutation(c config, op Op, opts ...diskOption) *DiskMutation {
	m := &DiskMutation{
		config:        c,
		op:            op,
		typ:           TypeDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiskID sets the id field of the mutation.
func withDiskID(id int) diskOption {
	return func(m *DiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Disk
		)
		m.oldValue = func(ctx context.Context) (*Disk, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisk sets the old Disk of the mutation.
func withDisk(node *Disk) diskOption {
	return func(m *DiskMutation) {
		m.oldValue = func(context.Context) (*Disk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSize sets the size field.
func (m *DiskMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the size value in the mutation.
func (m *DiskMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old size value of the Disk.
// If the Disk object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiskMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSize is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to size.
func (m *DiskMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the size field in this mutation.
func (m *DiskMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize reset all changes of the "size" field.
func (m *DiskMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *DiskMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *DiskMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *DiskMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *DiskMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *DiskMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *DiskMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *DiskMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *DiskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disk).
func (m *DiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DiskMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.size != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disk.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown Disk field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DiskMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DiskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disk nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DiskMutation) ResetField(name string) error {
	switch name {
	case disk.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, disk.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, disk.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DiskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, disk.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DiskMutation) EdgeCleared(name string) bool {
	switch name {
	case disk.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DiskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disk unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DiskMutation) ResetEdge(name string) error {
	switch name {
	case disk.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown Disk edge %s", name)
}

// EnvironmentMutation represents an operation that mutate the Environments
// nodes in the graph.
type EnvironmentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	competition_id          *string
	name                    *string
	description             *string
	builder                 *string
	team_count              *int
	addteam_count           *int
	revision                *int
	addrevision             *int
	admin_cidrs             *[]string
	exposed_vdi_ports       *[]string
	_config                 *map[string]string
	clearedFields           map[string]struct{}
	tag                     map[int]struct{}
	removedtag              map[int]struct{}
	clearedtag              bool
	user                    map[int]struct{}
	removeduser             map[int]struct{}
	cleareduser             bool
	host                    map[int]struct{}
	removedhost             map[int]struct{}
	clearedhost             bool
	competition             map[int]struct{}
	removedcompetition      map[int]struct{}
	clearedcompetition      bool
	build                   map[int]struct{}
	removedbuild            map[int]struct{}
	clearedbuild            bool
	included_network        map[int]struct{}
	removedincluded_network map[int]struct{}
	clearedincluded_network bool
	network                 map[int]struct{}
	removednetwork          map[int]struct{}
	clearednetwork          bool
	team                    map[int]struct{}
	removedteam             map[int]struct{}
	clearedteam             bool
	done                    bool
	oldValue                func(context.Context) (*Environment, error)
	predicates              []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows to manage the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for Environment.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the id field of the mutation.
func withEnvironmentID(id int) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EnvironmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCompetitionID sets the competition_id field.
func (m *EnvironmentMutation) SetCompetitionID(s string) {
	m.competition_id = &s
}

// CompetitionID returns the competition_id value in the mutation.
func (m *EnvironmentMutation) CompetitionID() (r string, exists bool) {
	v := m.competition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old competition_id value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompetitionID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID reset all changes of the "competition_id" field.
func (m *EnvironmentMutation) ResetCompetitionID() {
	m.competition_id = nil
}

// SetName sets the name field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
}

// SetBuilder sets the builder field.
func (m *EnvironmentMutation) SetBuilder(s string) {
	m.builder = &s
}

// Builder returns the builder value in the mutation.
func (m *EnvironmentMutation) Builder() (r string, exists bool) {
	v := m.builder
	if v == nil {
		return
	}
	return *v, true
}

// OldBuilder returns the old builder value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldBuilder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuilder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuilder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuilder: %w", err)
	}
	return oldValue.Builder, nil
}

// ResetBuilder reset all changes of the "builder" field.
func (m *EnvironmentMutation) ResetBuilder() {
	m.builder = nil
}

// SetTeamCount sets the team_count field.
func (m *EnvironmentMutation) SetTeamCount(i int) {
	m.team_count = &i
	m.addteam_count = nil
}

// TeamCount returns the team_count value in the mutation.
func (m *EnvironmentMutation) TeamCount() (r int, exists bool) {
	v := m.team_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamCount returns the old team_count value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldTeamCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeamCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeamCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamCount: %w", err)
	}
	return oldValue.TeamCount, nil
}

// AddTeamCount adds i to team_count.
func (m *EnvironmentMutation) AddTeamCount(i int) {
	if m.addteam_count != nil {
		*m.addteam_count += i
	} else {
		m.addteam_count = &i
	}
}

// AddedTeamCount returns the value that was added to the team_count field in this mutation.
func (m *EnvironmentMutation) AddedTeamCount() (r int, exists bool) {
	v := m.addteam_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamCount reset all changes of the "team_count" field.
func (m *EnvironmentMutation) ResetTeamCount() {
	m.team_count = nil
	m.addteam_count = nil
}

// SetRevision sets the revision field.
func (m *EnvironmentMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the revision value in the mutation.
func (m *EnvironmentMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old revision value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to revision.
func (m *EnvironmentMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the revision field in this mutation.
func (m *EnvironmentMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision reset all changes of the "revision" field.
func (m *EnvironmentMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetAdminCidrs sets the admin_cidrs field.
func (m *EnvironmentMutation) SetAdminCidrs(s []string) {
	m.admin_cidrs = &s
}

// AdminCidrs returns the admin_cidrs value in the mutation.
func (m *EnvironmentMutation) AdminCidrs() (r []string, exists bool) {
	v := m.admin_cidrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminCidrs returns the old admin_cidrs value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldAdminCidrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminCidrs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminCidrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminCidrs: %w", err)
	}
	return oldValue.AdminCidrs, nil
}

// ResetAdminCidrs reset all changes of the "admin_cidrs" field.
func (m *EnvironmentMutation) ResetAdminCidrs() {
	m.admin_cidrs = nil
}

// SetExposedVdiPorts sets the exposed_vdi_ports field.
func (m *EnvironmentMutation) SetExposedVdiPorts(s []string) {
	m.exposed_vdi_ports = &s
}

// ExposedVdiPorts returns the exposed_vdi_ports value in the mutation.
func (m *EnvironmentMutation) ExposedVdiPorts() (r []string, exists bool) {
	v := m.exposed_vdi_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedVdiPorts returns the old exposed_vdi_ports value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldExposedVdiPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExposedVdiPorts is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExposedVdiPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedVdiPorts: %w", err)
	}
	return oldValue.ExposedVdiPorts, nil
}

// ResetExposedVdiPorts reset all changes of the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) ResetExposedVdiPorts() {
	m.exposed_vdi_ports = nil
}

// SetConfig sets the config field.
func (m *EnvironmentMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the config value in the mutation.
func (m *EnvironmentMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old config value of the Environment.
// If the Environment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EnvironmentMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig reset all changes of the "config" field.
func (m *EnvironmentMutation) ResetConfig() {
	m._config = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *EnvironmentMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *EnvironmentMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *EnvironmentMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *EnvironmentMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *EnvironmentMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *EnvironmentMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *EnvironmentMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddUserIDs adds the user edge to User by ids.
func (m *EnvironmentMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the user edge to User.
func (m *EnvironmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *EnvironmentMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *EnvironmentMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *EnvironmentMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *EnvironmentMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *EnvironmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddHostIDs adds the host edge to Host by ids.
func (m *EnvironmentMutation) AddHostIDs(ids ...int) {
	if m.host == nil {
		m.host = make(map[int]struct{})
	}
	for i := range ids {
		m.host[ids[i]] = struct{}{}
	}
}

// ClearHost clears the host edge to Host.
func (m *EnvironmentMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared returns if the edge host was cleared.
func (m *EnvironmentMutation) HostCleared() bool {
	return m.clearedhost
}

// RemoveHostIDs removes the host edge to Host by ids.
func (m *EnvironmentMutation) RemoveHostIDs(ids ...int) {
	if m.removedhost == nil {
		m.removedhost = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhost[ids[i]] = struct{}{}
	}
}

// RemovedHost returns the removed ids of host.
func (m *EnvironmentMutation) RemovedHostIDs() (ids []int) {
	for id := range m.removedhost {
		ids = append(ids, id)
	}
	return
}

// HostIDs returns the host ids in the mutation.
func (m *EnvironmentMutation) HostIDs() (ids []int) {
	for id := range m.host {
		ids = append(ids, id)
	}
	return
}

// ResetHost reset all changes of the "host" edge.
func (m *EnvironmentMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
	m.removedhost = nil
}

// AddCompetitionIDs adds the competition edge to Competition by ids.
func (m *EnvironmentMutation) AddCompetitionIDs(ids ...int) {
	if m.competition == nil {
		m.competition = make(map[int]struct{})
	}
	for i := range ids {
		m.competition[ids[i]] = struct{}{}
	}
}

// ClearCompetition clears the competition edge to Competition.
func (m *EnvironmentMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared returns if the edge competition was cleared.
func (m *EnvironmentMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// RemoveCompetitionIDs removes the competition edge to Competition by ids.
func (m *EnvironmentMutation) RemoveCompetitionIDs(ids ...int) {
	if m.removedcompetition == nil {
		m.removedcompetition = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcompetition[ids[i]] = struct{}{}
	}
}

// RemovedCompetition returns the removed ids of competition.
func (m *EnvironmentMutation) RemovedCompetitionIDs() (ids []int) {
	for id := range m.removedcompetition {
		ids = append(ids, id)
	}
	return
}

// CompetitionIDs returns the competition ids in the mutation.
func (m *EnvironmentMutation) CompetitionIDs() (ids []int) {
	for id := range m.competition {
		ids = append(ids, id)
	}
	return
}

// ResetCompetition reset all changes of the "competition" edge.
func (m *EnvironmentMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
	m.removedcompetition = nil
}

// AddBuildIDs adds the build edge to Build by ids.
func (m *EnvironmentMutation) AddBuildIDs(ids ...int) {
	if m.build == nil {
		m.build = make(map[int]struct{})
	}
	for i := range ids {
		m.build[ids[i]] = struct{}{}
	}
}

// ClearBuild clears the build edge to Build.
func (m *EnvironmentMutation) ClearBuild() {
	m.clearedbuild = true
}

// BuildCleared returns if the edge build was cleared.
func (m *EnvironmentMutation) BuildCleared() bool {
	return m.clearedbuild
}

// RemoveBuildIDs removes the build edge to Build by ids.
func (m *EnvironmentMutation) RemoveBuildIDs(ids ...int) {
	if m.removedbuild == nil {
		m.removedbuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbuild[ids[i]] = struct{}{}
	}
}

// RemovedBuild returns the removed ids of build.
func (m *EnvironmentMutation) RemovedBuildIDs() (ids []int) {
	for id := range m.removedbuild {
		ids = append(ids, id)
	}
	return
}

// BuildIDs returns the build ids in the mutation.
func (m *EnvironmentMutation) BuildIDs() (ids []int) {
	for id := range m.build {
		ids = append(ids, id)
	}
	return
}

// ResetBuild reset all changes of the "build" edge.
func (m *EnvironmentMutation) ResetBuild() {
	m.build = nil
	m.clearedbuild = false
	m.removedbuild = nil
}

// AddIncludedNetworkIDs adds the included_network edge to IncludedNetwork by ids.
func (m *EnvironmentMutation) AddIncludedNetworkIDs(ids ...int) {
	if m.included_network == nil {
		m.included_network = make(map[int]struct{})
	}
	for i := range ids {
		m.included_network[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetwork clears the included_network edge to IncludedNetwork.
func (m *EnvironmentMutation) ClearIncludedNetwork() {
	m.clearedincluded_network = true
}

// IncludedNetworkCleared returns if the edge included_network was cleared.
func (m *EnvironmentMutation) IncludedNetworkCleared() bool {
	return m.clearedincluded_network
}

// RemoveIncludedNetworkIDs removes the included_network edge to IncludedNetwork by ids.
func (m *EnvironmentMutation) RemoveIncludedNetworkIDs(ids ...int) {
	if m.removedincluded_network == nil {
		m.removedincluded_network = make(map[int]struct{})
	}
	for i := range ids {
		m.removedincluded_network[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetwork returns the removed ids of included_network.
func (m *EnvironmentMutation) RemovedIncludedNetworkIDs() (ids []int) {
	for id := range m.removedincluded_network {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkIDs returns the included_network ids in the mutation.
func (m *EnvironmentMutation) IncludedNetworkIDs() (ids []int) {
	for id := range m.included_network {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetwork reset all changes of the "included_network" edge.
func (m *EnvironmentMutation) ResetIncludedNetwork() {
	m.included_network = nil
	m.clearedincluded_network = false
	m.removedincluded_network = nil
}

// AddNetworkIDs adds the network edge to Network by ids.
func (m *EnvironmentMutation) AddNetworkIDs(ids ...int) {
	if m.network == nil {
		m.network = make(map[int]struct{})
	}
	for i := range ids {
		m.network[ids[i]] = struct{}{}
	}
}

// ClearNetwork clears the network edge to Network.
func (m *EnvironmentMutation) ClearNetwork() {
	m.clearednetwork = true
}

// NetworkCleared returns if the edge network was cleared.
func (m *EnvironmentMutation) NetworkCleared() bool {
	return m.clearednetwork
}

// RemoveNetworkIDs removes the network edge to Network by ids.
func (m *EnvironmentMutation) RemoveNetworkIDs(ids ...int) {
	if m.removednetwork == nil {
		m.removednetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removednetwork[ids[i]] = struct{}{}
	}
}

// RemovedNetwork returns the removed ids of network.
func (m *EnvironmentMutation) RemovedNetworkIDs() (ids []int) {
	for id := range m.removednetwork {
		ids = append(ids, id)
	}
	return
}

// NetworkIDs returns the network ids in the mutation.
func (m *EnvironmentMutation) NetworkIDs() (ids []int) {
	for id := range m.network {
		ids = append(ids, id)
	}
	return
}

// ResetNetwork reset all changes of the "network" edge.
func (m *EnvironmentMutation) ResetNetwork() {
	m.network = nil
	m.clearednetwork = false
	m.removednetwork = nil
}

// AddTeamIDs adds the team edge to Team by ids.
func (m *EnvironmentMutation) AddTeamIDs(ids ...int) {
	if m.team == nil {
		m.team = make(map[int]struct{})
	}
	for i := range ids {
		m.team[ids[i]] = struct{}{}
	}
}

// ClearTeam clears the team edge to Team.
func (m *EnvironmentMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared returns if the edge team was cleared.
func (m *EnvironmentMutation) TeamCleared() bool {
	return m.clearedteam
}

// RemoveTeamIDs removes the team edge to Team by ids.
func (m *EnvironmentMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteam == nil {
		m.removedteam = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteam[ids[i]] = struct{}{}
	}
}

// RemovedTeam returns the removed ids of team.
func (m *EnvironmentMutation) RemovedTeamIDs() (ids []int) {
	for id := range m.removedteam {
		ids = append(ids, id)
	}
	return
}

// TeamIDs returns the team ids in the mutation.
func (m *EnvironmentMutation) TeamIDs() (ids []int) {
	for id := range m.team {
		ids = append(ids, id)
	}
	return
}

// ResetTeam reset all changes of the "team" edge.
func (m *EnvironmentMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
	m.removedteam = nil
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.competition_id != nil {
		fields = append(fields, environment.FieldCompetitionID)
	}
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.builder != nil {
		fields = append(fields, environment.FieldBuilder)
	}
	if m.team_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.revision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	if m.admin_cidrs != nil {
		fields = append(fields, environment.FieldAdminCidrs)
	}
	if m.exposed_vdi_ports != nil {
		fields = append(fields, environment.FieldExposedVdiPorts)
	}
	if m._config != nil {
		fields = append(fields, environment.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldCompetitionID:
		return m.CompetitionID()
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldBuilder:
		return m.Builder()
	case environment.FieldTeamCount:
		return m.TeamCount()
	case environment.FieldRevision:
		return m.Revision()
	case environment.FieldAdminCidrs:
		return m.AdminCidrs()
	case environment.FieldExposedVdiPorts:
		return m.ExposedVdiPorts()
	case environment.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldBuilder:
		return m.OldBuilder(ctx)
	case environment.FieldTeamCount:
		return m.OldTeamCount(ctx)
	case environment.FieldRevision:
		return m.OldRevision(ctx)
	case environment.FieldAdminCidrs:
		return m.OldAdminCidrs(ctx)
	case environment.FieldExposedVdiPorts:
		return m.OldExposedVdiPorts(ctx)
	case environment.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldBuilder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuilder(v)
		return nil
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case environment.FieldAdminCidrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminCidrs(v)
		return nil
	case environment.FieldExposedVdiPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedVdiPorts(v)
		return nil
	case environment.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	var fields []string
	if m.addteam_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.addrevision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldTeamCount:
		return m.AddedTeamCount()
	case environment.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldBuilder:
		m.ResetBuilder()
		return nil
	case environment.FieldTeamCount:
		m.ResetTeamCount()
		return nil
	case environment.FieldRevision:
		m.ResetRevision()
		return nil
	case environment.FieldAdminCidrs:
		m.ResetAdminCidrs()
		return nil
	case environment.FieldExposedVdiPorts:
		m.ResetExposedVdiPorts()
		return nil
	case environment.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tag != nil {
		edges = append(edges, environment.EdgeTag)
	}
	if m.user != nil {
		edges = append(edges, environment.EdgeUser)
	}
	if m.host != nil {
		edges = append(edges, environment.EdgeHost)
	}
	if m.competition != nil {
		edges = append(edges, environment.EdgeCompetition)
	}
	if m.build != nil {
		edges = append(edges, environment.EdgeBuild)
	}
	if m.included_network != nil {
		edges = append(edges, environment.EdgeIncludedNetwork)
	}
	if m.network != nil {
		edges = append(edges, environment.EdgeNetwork)
	}
	if m.team != nil {
		edges = append(edges, environment.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeHost:
		ids := make([]ent.Value, 0, len(m.host))
		for id := range m.host {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeCompetition:
		ids := make([]ent.Value, 0, len(m.competition))
		for id := range m.competition {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeBuild:
		ids := make([]ent.Value, 0, len(m.build))
		for id := range m.build {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.included_network))
		for id := range m.included_network {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeNetwork:
		ids := make([]ent.Value, 0, len(m.network))
		for id := range m.network {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.team))
		for id := range m.team {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedtag != nil {
		edges = append(edges, environment.EdgeTag)
	}
	if m.removeduser != nil {
		edges = append(edges, environment.EdgeUser)
	}
	if m.removedhost != nil {
		edges = append(edges, environment.EdgeHost)
	}
	if m.removedcompetition != nil {
		edges = append(edges, environment.EdgeCompetition)
	}
	if m.removedbuild != nil {
		edges = append(edges, environment.EdgeBuild)
	}
	if m.removedincluded_network != nil {
		edges = append(edges, environment.EdgeIncludedNetwork)
	}
	if m.removednetwork != nil {
		edges = append(edges, environment.EdgeNetwork)
	}
	if m.removedteam != nil {
		edges = append(edges, environment.EdgeTeam)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeHost:
		ids := make([]ent.Value, 0, len(m.removedhost))
		for id := range m.removedhost {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeCompetition:
		ids := make([]ent.Value, 0, len(m.removedcompetition))
		for id := range m.removedcompetition {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeBuild:
		ids := make([]ent.Value, 0, len(m.removedbuild))
		for id := range m.removedbuild {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removedincluded_network))
		for id := range m.removedincluded_network {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeNetwork:
		ids := make([]ent.Value, 0, len(m.removednetwork))
		for id := range m.removednetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.removedteam))
		for id := range m.removedteam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtag {
		edges = append(edges, environment.EdgeTag)
	}
	if m.cleareduser {
		edges = append(edges, environment.EdgeUser)
	}
	if m.clearedhost {
		edges = append(edges, environment.EdgeHost)
	}
	if m.clearedcompetition {
		edges = append(edges, environment.EdgeCompetition)
	}
	if m.clearedbuild {
		edges = append(edges, environment.EdgeBuild)
	}
	if m.clearedincluded_network {
		edges = append(edges, environment.EdgeIncludedNetwork)
	}
	if m.clearednetwork {
		edges = append(edges, environment.EdgeNetwork)
	}
	if m.clearedteam {
		edges = append(edges, environment.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeTag:
		return m.clearedtag
	case environment.EdgeUser:
		return m.cleareduser
	case environment.EdgeHost:
		return m.clearedhost
	case environment.EdgeCompetition:
		return m.clearedcompetition
	case environment.EdgeBuild:
		return m.clearedbuild
	case environment.EdgeIncludedNetwork:
		return m.clearedincluded_network
	case environment.EdgeNetwork:
		return m.clearednetwork
	case environment.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeTag:
		m.ResetTag()
		return nil
	case environment.EdgeUser:
		m.ResetUser()
		return nil
	case environment.EdgeHost:
		m.ResetHost()
		return nil
	case environment.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case environment.EdgeBuild:
		m.ResetBuild()
		return nil
	case environment.EdgeIncludedNetwork:
		m.ResetIncludedNetwork()
		return nil
	case environment.EdgeNetwork:
		m.ResetNetwork()
		return nil
	case environment.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// FileDeleteMutation represents an operation that mutate the FileDeletes
// nodes in the graph.
type FileDeleteMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_path         *string
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*FileDelete, error)
	predicates    []predicate.FileDelete
}

var _ ent.Mutation = (*FileDeleteMutation)(nil)

// filedeleteOption allows to manage the mutation configuration using functional options.
type filedeleteOption func(*FileDeleteMutation)

// newFileDeleteMutation creates new mutation for FileDelete.
func newFileDeleteMutation(c config, op Op, opts ...filedeleteOption) *FileDeleteMutation {
	m := &FileDeleteMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDelete,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDeleteID sets the id field of the mutation.
func withFileDeleteID(id int) filedeleteOption {
	return func(m *FileDeleteMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDelete
		)
		m.oldValue = func(ctx context.Context) (*FileDelete, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDelete.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDelete sets the old FileDelete of the mutation.
func withFileDelete(node *FileDelete) filedeleteOption {
	return func(m *FileDeleteMutation) {
		m.oldValue = func(context.Context) (*FileDelete, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDeleteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDeleteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FileDeleteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPath sets the path field.
func (m *FileDeleteMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the path value in the mutation.
func (m *FileDeleteMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old path value of the FileDelete.
// If the FileDelete object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDeleteMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath reset all changes of the "path" field.
func (m *FileDeleteMutation) ResetPath() {
	m._path = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *FileDeleteMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *FileDeleteMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *FileDeleteMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *FileDeleteMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *FileDeleteMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *FileDeleteMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *FileDeleteMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *FileDeleteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileDelete).
func (m *FileDeleteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FileDeleteMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._path != nil {
		fields = append(fields, filedelete.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FileDeleteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedelete.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FileDeleteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedelete.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown FileDelete field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileDeleteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedelete.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FileDeleteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FileDeleteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileDeleteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDelete numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FileDeleteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FileDeleteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDeleteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDelete nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FileDeleteMutation) ResetField(name string) error {
	switch name {
	case filedelete.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FileDeleteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, filedelete.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FileDeleteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedelete.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FileDeleteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, filedelete.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FileDeleteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filedelete.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FileDeleteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, filedelete.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FileDeleteMutation) EdgeCleared(name string) bool {
	switch name {
	case filedelete.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FileDeleteMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDelete unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FileDeleteMutation) ResetEdge(name string) error {
	switch name {
	case filedelete.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown FileDelete edge %s", name)
}

// FileDownloadMutation represents an operation that mutate the FileDownloads
// nodes in the graph.
type FileDownloadMutation struct {
	config
	op            Op
	typ           string
	id            *int
	source_type   *string
	source        *string
	destination   *string
	template      *bool
	mode          *string
	disabled      *bool
	md5           *string
	abs_path      *string
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*FileDownload, error)
	predicates    []predicate.FileDownload
}

var _ ent.Mutation = (*FileDownloadMutation)(nil)

// filedownloadOption allows to manage the mutation configuration using functional options.
type filedownloadOption func(*FileDownloadMutation)

// newFileDownloadMutation creates new mutation for FileDownload.
func newFileDownloadMutation(c config, op Op, opts ...filedownloadOption) *FileDownloadMutation {
	m := &FileDownloadMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDownload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDownloadID sets the id field of the mutation.
func withFileDownloadID(id int) filedownloadOption {
	return func(m *FileDownloadMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDownload
		)
		m.oldValue = func(ctx context.Context) (*FileDownload, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDownload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDownload sets the old FileDownload of the mutation.
func withFileDownload(node *FileDownload) filedownloadOption {
	return func(m *FileDownloadMutation) {
		m.oldValue = func(context.Context) (*FileDownload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDownloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDownloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FileDownloadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSourceType sets the source_type field.
func (m *FileDownloadMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the source_type value in the mutation.
func (m *FileDownloadMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old source_type value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType reset all changes of the "source_type" field.
func (m *FileDownloadMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSource sets the source field.
func (m *FileDownloadMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the source value in the mutation.
func (m *FileDownloadMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old source value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource reset all changes of the "source" field.
func (m *FileDownloadMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the destination field.
func (m *FileDownloadMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the destination value in the mutation.
func (m *FileDownloadMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old destination value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDestination is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination reset all changes of the "destination" field.
func (m *FileDownloadMutation) ResetDestination() {
	m.destination = nil
}

// SetTemplate sets the template field.
func (m *FileDownloadMutation) SetTemplate(b bool) {
	m.template = &b
}

// Template returns the template value in the mutation.
func (m *FileDownloadMutation) Template() (r bool, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old template value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate reset all changes of the "template" field.
func (m *FileDownloadMutation) ResetTemplate() {
	m.template = nil
}

// SetMode sets the mode field.
func (m *FileDownloadMutation) SetMode(s string) {
	m.mode = &s
}

// Mode returns the mode value in the mutation.
func (m *FileDownloadMutation) Mode() (r string, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old mode value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode reset all changes of the "mode" field.
func (m *FileDownloadMutation) ResetMode() {
	m.mode = nil
}

// SetDisabled sets the disabled field.
func (m *FileDownloadMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the disabled value in the mutation.
func (m *FileDownloadMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old disabled value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled reset all changes of the "disabled" field.
func (m *FileDownloadMutation) ResetDisabled() {
	m.disabled = nil
}

// SetMd5 sets the md5 field.
func (m *FileDownloadMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the md5 value in the mutation.
func (m *FileDownloadMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old md5 value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMd5 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 reset all changes of the "md5" field.
func (m *FileDownloadMutation) ResetMd5() {
	m.md5 = nil
}

// SetAbsPath sets the abs_path field.
func (m *FileDownloadMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the abs_path value in the mutation.
func (m *FileDownloadMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old abs_path value of the FileDownload.
// If the FileDownload object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileDownloadMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbsPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath reset all changes of the "abs_path" field.
func (m *FileDownloadMutation) ResetAbsPath() {
	m.abs_path = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *FileDownloadMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *FileDownloadMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *FileDownloadMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *FileDownloadMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *FileDownloadMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *FileDownloadMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *FileDownloadMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *FileDownloadMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileDownload).
func (m *FileDownloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FileDownloadMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.source_type != nil {
		fields = append(fields, filedownload.FieldSourceType)
	}
	if m.source != nil {
		fields = append(fields, filedownload.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, filedownload.FieldDestination)
	}
	if m.template != nil {
		fields = append(fields, filedownload.FieldTemplate)
	}
	if m.mode != nil {
		fields = append(fields, filedownload.FieldMode)
	}
	if m.disabled != nil {
		fields = append(fields, filedownload.FieldDisabled)
	}
	if m.md5 != nil {
		fields = append(fields, filedownload.FieldMd5)
	}
	if m.abs_path != nil {
		fields = append(fields, filedownload.FieldAbsPath)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FileDownloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedownload.FieldSourceType:
		return m.SourceType()
	case filedownload.FieldSource:
		return m.Source()
	case filedownload.FieldDestination:
		return m.Destination()
	case filedownload.FieldTemplate:
		return m.Template()
	case filedownload.FieldMode:
		return m.Mode()
	case filedownload.FieldDisabled:
		return m.Disabled()
	case filedownload.FieldMd5:
		return m.Md5()
	case filedownload.FieldAbsPath:
		return m.AbsPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FileDownloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedownload.FieldSourceType:
		return m.OldSourceType(ctx)
	case filedownload.FieldSource:
		return m.OldSource(ctx)
	case filedownload.FieldDestination:
		return m.OldDestination(ctx)
	case filedownload.FieldTemplate:
		return m.OldTemplate(ctx)
	case filedownload.FieldMode:
		return m.OldMode(ctx)
	case filedownload.FieldDisabled:
		return m.OldDisabled(ctx)
	case filedownload.FieldMd5:
		return m.OldMd5(ctx)
	case filedownload.FieldAbsPath:
		return m.OldAbsPath(ctx)
	}
	return nil, fmt.Errorf("unknown FileDownload field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileDownloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedownload.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case filedownload.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case filedownload.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case filedownload.FieldTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case filedownload.FieldMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case filedownload.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case filedownload.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case filedownload.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FileDownloadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FileDownloadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileDownloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDownload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FileDownloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FileDownloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDownloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDownload nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FileDownloadMutation) ResetField(name string) error {
	switch name {
	case filedownload.FieldSourceType:
		m.ResetSourceType()
		return nil
	case filedownload.FieldSource:
		m.ResetSource()
		return nil
	case filedownload.FieldDestination:
		m.ResetDestination()
		return nil
	case filedownload.FieldTemplate:
		m.ResetTemplate()
		return nil
	case filedownload.FieldMode:
		m.ResetMode()
		return nil
	case filedownload.FieldDisabled:
		m.ResetDisabled()
		return nil
	case filedownload.FieldMd5:
		m.ResetMd5()
		return nil
	case filedownload.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FileDownloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, filedownload.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FileDownloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedownload.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FileDownloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, filedownload.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FileDownloadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filedownload.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FileDownloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, filedownload.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FileDownloadMutation) EdgeCleared(name string) bool {
	switch name {
	case filedownload.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FileDownloadMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDownload unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FileDownloadMutation) ResetEdge(name string) error {
	switch name {
	case filedownload.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown FileDownload edge %s", name)
}

// FileExtractMutation represents an operation that mutate the FileExtracts
// nodes in the graph.
type FileExtractMutation struct {
	config
	op            Op
	typ           string
	id            *int
	source        *string
	destination   *string
	_type         *string
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*FileExtract, error)
	predicates    []predicate.FileExtract
}

var _ ent.Mutation = (*FileExtractMutation)(nil)

// fileextractOption allows to manage the mutation configuration using functional options.
type fileextractOption func(*FileExtractMutation)

// newFileExtractMutation creates new mutation for FileExtract.
func newFileExtractMutation(c config, op Op, opts ...fileextractOption) *FileExtractMutation {
	m := &FileExtractMutation{
		config:        c,
		op:            op,
		typ:           TypeFileExtract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileExtractID sets the id field of the mutation.
func withFileExtractID(id int) fileextractOption {
	return func(m *FileExtractMutation) {
		var (
			err   error
			once  sync.Once
			value *FileExtract
		)
		m.oldValue = func(ctx context.Context) (*FileExtract, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileExtract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileExtract sets the old FileExtract of the mutation.
func withFileExtract(node *FileExtract) fileextractOption {
	return func(m *FileExtractMutation) {
		m.oldValue = func(context.Context) (*FileExtract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileExtractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileExtractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FileExtractMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSource sets the source field.
func (m *FileExtractMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the source value in the mutation.
func (m *FileExtractMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old source value of the FileExtract.
// If the FileExtract object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileExtractMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource reset all changes of the "source" field.
func (m *FileExtractMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the destination field.
func (m *FileExtractMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the destination value in the mutation.
func (m *FileExtractMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old destination value of the FileExtract.
// If the FileExtract object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileExtractMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDestination is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination reset all changes of the "destination" field.
func (m *FileExtractMutation) ResetDestination() {
	m.destination = nil
}

// SetType sets the type field.
func (m *FileExtractMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *FileExtractMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the FileExtract.
// If the FileExtract object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileExtractMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *FileExtractMutation) ResetType() {
	m._type = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *FileExtractMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *FileExtractMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *FileExtractMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *FileExtractMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *FileExtractMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *FileExtractMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *FileExtractMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *FileExtractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileExtract).
func (m *FileExtractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FileExtractMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.source != nil {
		fields = append(fields, fileextract.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, fileextract.FieldDestination)
	}
	if m._type != nil {
		fields = append(fields, fileextract.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FileExtractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileextract.FieldSource:
		return m.Source()
	case fileextract.FieldDestination:
		return m.Destination()
	case fileextract.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FileExtractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileextract.FieldSource:
		return m.OldSource(ctx)
	case fileextract.FieldDestination:
		return m.OldDestination(ctx)
	case fileextract.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown FileExtract field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileExtractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileextract.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case fileextract.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case fileextract.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FileExtractMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FileExtractMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileExtractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileExtract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FileExtractMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FileExtractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileExtractMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileExtract nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FileExtractMutation) ResetField(name string) error {
	switch name {
	case fileextract.FieldSource:
		m.ResetSource()
		return nil
	case fileextract.FieldDestination:
		m.ResetDestination()
		return nil
	case fileextract.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FileExtractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, fileextract.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FileExtractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileextract.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FileExtractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, fileextract.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FileExtractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fileextract.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FileExtractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, fileextract.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FileExtractMutation) EdgeCleared(name string) bool {
	switch name {
	case fileextract.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FileExtractMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileExtract unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FileExtractMutation) ResetEdge(name string) error {
	switch name {
	case fileextract.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown FileExtract edge %s", name)
}

// FindingMutation represents an operation that mutate the Findings
// nodes in the graph.
type FindingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	severity      *finding.Severity
	difficulty    *finding.Difficulty
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	host          map[int]struct{}
	removedhost   map[int]struct{}
	clearedhost   bool
	script        map[int]struct{}
	removedscript map[int]struct{}
	clearedscript bool
	done          bool
	oldValue      func(context.Context) (*Finding, error)
	predicates    []predicate.Finding
}

var _ ent.Mutation = (*FindingMutation)(nil)

// findingOption allows to manage the mutation configuration using functional options.
type findingOption func(*FindingMutation)

// newFindingMutation creates new mutation for Finding.
func newFindingMutation(c config, op Op, opts ...findingOption) *FindingMutation {
	m := &FindingMutation{
		config:        c,
		op:            op,
		typ:           TypeFinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFindingID sets the id field of the mutation.
func withFindingID(id int) findingOption {
	return func(m *FindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Finding
		)
		m.oldValue = func(ctx context.Context) (*Finding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Finding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinding sets the old Finding of the mutation.
func withFinding(node *Finding) findingOption {
	return func(m *FindingMutation) {
		m.oldValue = func(context.Context) (*Finding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FindingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FindingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FindingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Finding.
// If the Finding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FindingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FindingMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *FindingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *FindingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Finding.
// If the Finding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FindingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *FindingMutation) ResetDescription() {
	m.description = nil
}

// SetSeverity sets the severity field.
func (m *FindingMutation) SetSeverity(f finding.Severity) {
	m.severity = &f
}

// Severity returns the severity value in the mutation.
func (m *FindingMutation) Severity() (r finding.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old severity value of the Finding.
// If the Finding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FindingMutation) OldSeverity(ctx context.Context) (v finding.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity reset all changes of the "severity" field.
func (m *FindingMutation) ResetSeverity() {
	m.severity = nil
}

// SetDifficulty sets the difficulty field.
func (m *FindingMutation) SetDifficulty(f finding.Difficulty) {
	m.difficulty = &f
}

// Difficulty returns the difficulty value in the mutation.
func (m *FindingMutation) Difficulty() (r finding.Difficulty, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old difficulty value of the Finding.
// If the Finding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FindingMutation) OldDifficulty(ctx context.Context) (v finding.Difficulty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDifficulty is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// ResetDifficulty reset all changes of the "difficulty" field.
func (m *FindingMutation) ResetDifficulty() {
	m.difficulty = nil
}

// AddUserIDs adds the user edge to User by ids.
func (m *FindingMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the user edge to User.
func (m *FindingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *FindingMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *FindingMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *FindingMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *FindingMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *FindingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *FindingMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *FindingMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *FindingMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *FindingMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *FindingMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *FindingMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *FindingMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddHostIDs adds the host edge to Host by ids.
func (m *FindingMutation) AddHostIDs(ids ...int) {
	if m.host == nil {
		m.host = make(map[int]struct{})
	}
	for i := range ids {
		m.host[ids[i]] = struct{}{}
	}
}

// ClearHost clears the host edge to Host.
func (m *FindingMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared returns if the edge host was cleared.
func (m *FindingMutation) HostCleared() bool {
	return m.clearedhost
}

// RemoveHostIDs removes the host edge to Host by ids.
func (m *FindingMutation) RemoveHostIDs(ids ...int) {
	if m.removedhost == nil {
		m.removedhost = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhost[ids[i]] = struct{}{}
	}
}

// RemovedHost returns the removed ids of host.
func (m *FindingMutation) RemovedHostIDs() (ids []int) {
	for id := range m.removedhost {
		ids = append(ids, id)
	}
	return
}

// HostIDs returns the host ids in the mutation.
func (m *FindingMutation) HostIDs() (ids []int) {
	for id := range m.host {
		ids = append(ids, id)
	}
	return
}

// ResetHost reset all changes of the "host" edge.
func (m *FindingMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
	m.removedhost = nil
}

// AddScriptIDs adds the script edge to Script by ids.
func (m *FindingMutation) AddScriptIDs(ids ...int) {
	if m.script == nil {
		m.script = make(map[int]struct{})
	}
	for i := range ids {
		m.script[ids[i]] = struct{}{}
	}
}

// ClearScript clears the script edge to Script.
func (m *FindingMutation) ClearScript() {
	m.clearedscript = true
}

// ScriptCleared returns if the edge script was cleared.
func (m *FindingMutation) ScriptCleared() bool {
	return m.clearedscript
}

// RemoveScriptIDs removes the script edge to Script by ids.
func (m *FindingMutation) RemoveScriptIDs(ids ...int) {
	if m.removedscript == nil {
		m.removedscript = make(map[int]struct{})
	}
	for i := range ids {
		m.removedscript[ids[i]] = struct{}{}
	}
}

// RemovedScript returns the removed ids of script.
func (m *FindingMutation) RemovedScriptIDs() (ids []int) {
	for id := range m.removedscript {
		ids = append(ids, id)
	}
	return
}

// ScriptIDs returns the script ids in the mutation.
func (m *FindingMutation) ScriptIDs() (ids []int) {
	for id := range m.script {
		ids = append(ids, id)
	}
	return
}

// ResetScript reset all changes of the "script" edge.
func (m *FindingMutation) ResetScript() {
	m.script = nil
	m.clearedscript = false
	m.removedscript = nil
}

// Op returns the operation name.
func (m *FindingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Finding).
func (m *FindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FindingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, finding.FieldName)
	}
	if m.description != nil {
		fields = append(fields, finding.FieldDescription)
	}
	if m.severity != nil {
		fields = append(fields, finding.FieldSeverity)
	}
	if m.difficulty != nil {
		fields = append(fields, finding.FieldDifficulty)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case finding.FieldName:
		return m.Name()
	case finding.FieldDescription:
		return m.Description()
	case finding.FieldSeverity:
		return m.Severity()
	case finding.FieldDifficulty:
		return m.Difficulty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case finding.FieldName:
		return m.OldName(ctx)
	case finding.FieldDescription:
		return m.OldDescription(ctx)
	case finding.FieldSeverity:
		return m.OldSeverity(ctx)
	case finding.FieldDifficulty:
		return m.OldDifficulty(ctx)
	}
	return nil, fmt.Errorf("unknown Finding field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case finding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case finding.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case finding.FieldSeverity:
		v, ok := value.(finding.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case finding.FieldDifficulty:
		v, ok := value.(finding.Difficulty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Finding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Finding nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FindingMutation) ResetField(name string) error {
	switch name {
	case finding.FieldName:
		m.ResetName()
		return nil
	case finding.FieldDescription:
		m.ResetDescription()
		return nil
	case finding.FieldSeverity:
		m.ResetSeverity()
		return nil
	case finding.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, finding.EdgeUser)
	}
	if m.tag != nil {
		edges = append(edges, finding.EdgeTag)
	}
	if m.host != nil {
		edges = append(edges, finding.EdgeHost)
	}
	if m.script != nil {
		edges = append(edges, finding.EdgeScript)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeHost:
		ids := make([]ent.Value, 0, len(m.host))
		for id := range m.host {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeScript:
		ids := make([]ent.Value, 0, len(m.script))
		for id := range m.script {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser != nil {
		edges = append(edges, finding.EdgeUser)
	}
	if m.removedtag != nil {
		edges = append(edges, finding.EdgeTag)
	}
	if m.removedhost != nil {
		edges = append(edges, finding.EdgeHost)
	}
	if m.removedscript != nil {
		edges = append(edges, finding.EdgeScript)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FindingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeHost:
		ids := make([]ent.Value, 0, len(m.removedhost))
		for id := range m.removedhost {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeScript:
		ids := make([]ent.Value, 0, len(m.removedscript))
		for id := range m.removedscript {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, finding.EdgeUser)
	}
	if m.clearedtag {
		edges = append(edges, finding.EdgeTag)
	}
	if m.clearedhost {
		edges = append(edges, finding.EdgeHost)
	}
	if m.clearedscript {
		edges = append(edges, finding.EdgeScript)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FindingMutation) EdgeCleared(name string) bool {
	switch name {
	case finding.EdgeUser:
		return m.cleareduser
	case finding.EdgeTag:
		return m.clearedtag
	case finding.EdgeHost:
		return m.clearedhost
	case finding.EdgeScript:
		return m.clearedscript
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FindingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Finding unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FindingMutation) ResetEdge(name string) error {
	switch name {
	case finding.EdgeUser:
		m.ResetUser()
		return nil
	case finding.EdgeTag:
		m.ResetTag()
		return nil
	case finding.EdgeHost:
		m.ResetHost()
		return nil
	case finding.EdgeScript:
		m.ResetScript()
		return nil
	}
	return fmt.Errorf("unknown Finding edge %s", name)
}

// HostMutation represents an operation that mutate the Hosts
// nodes in the graph.
type HostMutation struct {
	config
	op                Op
	typ               string
	id                *int
	hostname          *string
	description       *string
	_OS               *string
	last_octet        *int
	addlast_octet     *int
	allow_mac_changes *bool
	exposed_tcp_ports *[]string
	exposed_udp_ports *[]string
	override_password *string
	vars              *map[string]string
	user_groups       *[]string
	depends_on        *[]string
	scripts           *[]string
	commands          *[]string
	remote_files      *[]string
	dns_records       *[]string
	clearedFields     map[string]struct{}
	disk              map[int]struct{}
	removeddisk       map[int]struct{}
	cleareddisk       bool
	maintainer        map[int]struct{}
	removedmaintainer map[int]struct{}
	clearedmaintainer bool
	tag               map[int]struct{}
	removedtag        map[int]struct{}
	clearedtag        bool
	done              bool
	oldValue          func(context.Context) (*Host, error)
	predicates        []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows to manage the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for Host.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the id field of the mutation.
func withHostID(id int) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHostname sets the hostname field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the hostname value in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old hostname value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname reset all changes of the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetDescription sets the description field.
func (m *HostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *HostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *HostMutation) ResetDescription() {
	m.description = nil
}

// SetOS sets the OS field.
func (m *HostMutation) SetOS(s string) {
	m._OS = &s
}

// OS returns the OS value in the mutation.
func (m *HostMutation) OS() (r string, exists bool) {
	v := m._OS
	if v == nil {
		return
	}
	return *v, true
}

// OldOS returns the old OS value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOS: %w", err)
	}
	return oldValue.OS, nil
}

// ResetOS reset all changes of the "OS" field.
func (m *HostMutation) ResetOS() {
	m._OS = nil
}

// SetLastOctet sets the last_octet field.
func (m *HostMutation) SetLastOctet(i int) {
	m.last_octet = &i
	m.addlast_octet = nil
}

// LastOctet returns the last_octet value in the mutation.
func (m *HostMutation) LastOctet() (r int, exists bool) {
	v := m.last_octet
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOctet returns the old last_octet value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldLastOctet(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastOctet is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastOctet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOctet: %w", err)
	}
	return oldValue.LastOctet, nil
}

// AddLastOctet adds i to last_octet.
func (m *HostMutation) AddLastOctet(i int) {
	if m.addlast_octet != nil {
		*m.addlast_octet += i
	} else {
		m.addlast_octet = &i
	}
}

// AddedLastOctet returns the value that was added to the last_octet field in this mutation.
func (m *HostMutation) AddedLastOctet() (r int, exists bool) {
	v := m.addlast_octet
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastOctet reset all changes of the "last_octet" field.
func (m *HostMutation) ResetLastOctet() {
	m.last_octet = nil
	m.addlast_octet = nil
}

// SetAllowMACChanges sets the allow_mac_changes field.
func (m *HostMutation) SetAllowMACChanges(b bool) {
	m.allow_mac_changes = &b
}

// AllowMACChanges returns the allow_mac_changes value in the mutation.
func (m *HostMutation) AllowMACChanges() (r bool, exists bool) {
	v := m.allow_mac_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowMACChanges returns the old allow_mac_changes value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldAllowMACChanges(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllowMACChanges is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllowMACChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowMACChanges: %w", err)
	}
	return oldValue.AllowMACChanges, nil
}

// ResetAllowMACChanges reset all changes of the "allow_mac_changes" field.
func (m *HostMutation) ResetAllowMACChanges() {
	m.allow_mac_changes = nil
}

// SetExposedTCPPorts sets the exposed_tcp_ports field.
func (m *HostMutation) SetExposedTCPPorts(s []string) {
	m.exposed_tcp_ports = &s
}

// ExposedTCPPorts returns the exposed_tcp_ports value in the mutation.
func (m *HostMutation) ExposedTCPPorts() (r []string, exists bool) {
	v := m.exposed_tcp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedTCPPorts returns the old exposed_tcp_ports value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldExposedTCPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExposedTCPPorts is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExposedTCPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedTCPPorts: %w", err)
	}
	return oldValue.ExposedTCPPorts, nil
}

// ResetExposedTCPPorts reset all changes of the "exposed_tcp_ports" field.
func (m *HostMutation) ResetExposedTCPPorts() {
	m.exposed_tcp_ports = nil
}

// SetExposedUDPPorts sets the exposed_udp_ports field.
func (m *HostMutation) SetExposedUDPPorts(s []string) {
	m.exposed_udp_ports = &s
}

// ExposedUDPPorts returns the exposed_udp_ports value in the mutation.
func (m *HostMutation) ExposedUDPPorts() (r []string, exists bool) {
	v := m.exposed_udp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedUDPPorts returns the old exposed_udp_ports value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldExposedUDPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExposedUDPPorts is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExposedUDPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedUDPPorts: %w", err)
	}
	return oldValue.ExposedUDPPorts, nil
}

// ResetExposedUDPPorts reset all changes of the "exposed_udp_ports" field.
func (m *HostMutation) ResetExposedUDPPorts() {
	m.exposed_udp_ports = nil
}

// SetOverridePassword sets the override_password field.
func (m *HostMutation) SetOverridePassword(s string) {
	m.override_password = &s
}

// OverridePassword returns the override_password value in the mutation.
func (m *HostMutation) OverridePassword() (r string, exists bool) {
	v := m.override_password
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePassword returns the old override_password value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldOverridePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOverridePassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOverridePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePassword: %w", err)
	}
	return oldValue.OverridePassword, nil
}

// ResetOverridePassword reset all changes of the "override_password" field.
func (m *HostMutation) ResetOverridePassword() {
	m.override_password = nil
}

// SetVars sets the vars field.
func (m *HostMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the vars value in the mutation.
func (m *HostMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old vars value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars reset all changes of the "vars" field.
func (m *HostMutation) ResetVars() {
	m.vars = nil
}

// SetUserGroups sets the user_groups field.
func (m *HostMutation) SetUserGroups(s []string) {
	m.user_groups = &s
}

// UserGroups returns the user_groups value in the mutation.
func (m *HostMutation) UserGroups() (r []string, exists bool) {
	v := m.user_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldUserGroups returns the old user_groups value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldUserGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserGroups is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserGroups: %w", err)
	}
	return oldValue.UserGroups, nil
}

// ResetUserGroups reset all changes of the "user_groups" field.
func (m *HostMutation) ResetUserGroups() {
	m.user_groups = nil
}

// SetDependsOn sets the depends_on field.
func (m *HostMutation) SetDependsOn(s []string) {
	m.depends_on = &s
}

// DependsOn returns the depends_on value in the mutation.
func (m *HostMutation) DependsOn() (r []string, exists bool) {
	v := m.depends_on
	if v == nil {
		return
	}
	return *v, true
}

// OldDependsOn returns the old depends_on value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldDependsOn(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDependsOn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDependsOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependsOn: %w", err)
	}
	return oldValue.DependsOn, nil
}

// ClearDependsOn clears the value of depends_on.
func (m *HostMutation) ClearDependsOn() {
	m.depends_on = nil
	m.clearedFields[host.FieldDependsOn] = struct{}{}
}

// DependsOnCleared returns if the field depends_on was cleared in this mutation.
func (m *HostMutation) DependsOnCleared() bool {
	_, ok := m.clearedFields[host.FieldDependsOn]
	return ok
}

// ResetDependsOn reset all changes of the "depends_on" field.
func (m *HostMutation) ResetDependsOn() {
	m.depends_on = nil
	delete(m.clearedFields, host.FieldDependsOn)
}

// SetScripts sets the scripts field.
func (m *HostMutation) SetScripts(s []string) {
	m.scripts = &s
}

// Scripts returns the scripts value in the mutation.
func (m *HostMutation) Scripts() (r []string, exists bool) {
	v := m.scripts
	if v == nil {
		return
	}
	return *v, true
}

// OldScripts returns the old scripts value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldScripts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScripts is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScripts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScripts: %w", err)
	}
	return oldValue.Scripts, nil
}

// ClearScripts clears the value of scripts.
func (m *HostMutation) ClearScripts() {
	m.scripts = nil
	m.clearedFields[host.FieldScripts] = struct{}{}
}

// ScriptsCleared returns if the field scripts was cleared in this mutation.
func (m *HostMutation) ScriptsCleared() bool {
	_, ok := m.clearedFields[host.FieldScripts]
	return ok
}

// ResetScripts reset all changes of the "scripts" field.
func (m *HostMutation) ResetScripts() {
	m.scripts = nil
	delete(m.clearedFields, host.FieldScripts)
}

// SetCommands sets the commands field.
func (m *HostMutation) SetCommands(s []string) {
	m.commands = &s
}

// Commands returns the commands value in the mutation.
func (m *HostMutation) Commands() (r []string, exists bool) {
	v := m.commands
	if v == nil {
		return
	}
	return *v, true
}

// OldCommands returns the old commands value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldCommands(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommands is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommands requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommands: %w", err)
	}
	return oldValue.Commands, nil
}

// ClearCommands clears the value of commands.
func (m *HostMutation) ClearCommands() {
	m.commands = nil
	m.clearedFields[host.FieldCommands] = struct{}{}
}

// CommandsCleared returns if the field commands was cleared in this mutation.
func (m *HostMutation) CommandsCleared() bool {
	_, ok := m.clearedFields[host.FieldCommands]
	return ok
}

// ResetCommands reset all changes of the "commands" field.
func (m *HostMutation) ResetCommands() {
	m.commands = nil
	delete(m.clearedFields, host.FieldCommands)
}

// SetRemoteFiles sets the remote_files field.
func (m *HostMutation) SetRemoteFiles(s []string) {
	m.remote_files = &s
}

// RemoteFiles returns the remote_files value in the mutation.
func (m *HostMutation) RemoteFiles() (r []string, exists bool) {
	v := m.remote_files
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteFiles returns the old remote_files value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldRemoteFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemoteFiles is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemoteFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteFiles: %w", err)
	}
	return oldValue.RemoteFiles, nil
}

// ClearRemoteFiles clears the value of remote_files.
func (m *HostMutation) ClearRemoteFiles() {
	m.remote_files = nil
	m.clearedFields[host.FieldRemoteFiles] = struct{}{}
}

// RemoteFilesCleared returns if the field remote_files was cleared in this mutation.
func (m *HostMutation) RemoteFilesCleared() bool {
	_, ok := m.clearedFields[host.FieldRemoteFiles]
	return ok
}

// ResetRemoteFiles reset all changes of the "remote_files" field.
func (m *HostMutation) ResetRemoteFiles() {
	m.remote_files = nil
	delete(m.clearedFields, host.FieldRemoteFiles)
}

// SetDNSRecords sets the dns_records field.
func (m *HostMutation) SetDNSRecords(s []string) {
	m.dns_records = &s
}

// DNSRecords returns the dns_records value in the mutation.
func (m *HostMutation) DNSRecords() (r []string, exists bool) {
	v := m.dns_records
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSRecords returns the old dns_records value of the Host.
// If the Host object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HostMutation) OldDNSRecords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDNSRecords is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDNSRecords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSRecords: %w", err)
	}
	return oldValue.DNSRecords, nil
}

// ClearDNSRecords clears the value of dns_records.
func (m *HostMutation) ClearDNSRecords() {
	m.dns_records = nil
	m.clearedFields[host.FieldDNSRecords] = struct{}{}
}

// DNSRecordsCleared returns if the field dns_records was cleared in this mutation.
func (m *HostMutation) DNSRecordsCleared() bool {
	_, ok := m.clearedFields[host.FieldDNSRecords]
	return ok
}

// ResetDNSRecords reset all changes of the "dns_records" field.
func (m *HostMutation) ResetDNSRecords() {
	m.dns_records = nil
	delete(m.clearedFields, host.FieldDNSRecords)
}

// AddDiskIDs adds the disk edge to Disk by ids.
func (m *HostMutation) AddDiskIDs(ids ...int) {
	if m.disk == nil {
		m.disk = make(map[int]struct{})
	}
	for i := range ids {
		m.disk[ids[i]] = struct{}{}
	}
}

// ClearDisk clears the disk edge to Disk.
func (m *HostMutation) ClearDisk() {
	m.cleareddisk = true
}

// DiskCleared returns if the edge disk was cleared.
func (m *HostMutation) DiskCleared() bool {
	return m.cleareddisk
}

// RemoveDiskIDs removes the disk edge to Disk by ids.
func (m *HostMutation) RemoveDiskIDs(ids ...int) {
	if m.removeddisk == nil {
		m.removeddisk = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddisk[ids[i]] = struct{}{}
	}
}

// RemovedDisk returns the removed ids of disk.
func (m *HostMutation) RemovedDiskIDs() (ids []int) {
	for id := range m.removeddisk {
		ids = append(ids, id)
	}
	return
}

// DiskIDs returns the disk ids in the mutation.
func (m *HostMutation) DiskIDs() (ids []int) {
	for id := range m.disk {
		ids = append(ids, id)
	}
	return
}

// ResetDisk reset all changes of the "disk" edge.
func (m *HostMutation) ResetDisk() {
	m.disk = nil
	m.cleareddisk = false
	m.removeddisk = nil
}

// AddMaintainerIDs adds the maintainer edge to User by ids.
func (m *HostMutation) AddMaintainerIDs(ids ...int) {
	if m.maintainer == nil {
		m.maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.maintainer[ids[i]] = struct{}{}
	}
}

// ClearMaintainer clears the maintainer edge to User.
func (m *HostMutation) ClearMaintainer() {
	m.clearedmaintainer = true
}

// MaintainerCleared returns if the edge maintainer was cleared.
func (m *HostMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// RemoveMaintainerIDs removes the maintainer edge to User by ids.
func (m *HostMutation) RemoveMaintainerIDs(ids ...int) {
	if m.removedmaintainer == nil {
		m.removedmaintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmaintainer[ids[i]] = struct{}{}
	}
}

// RemovedMaintainer returns the removed ids of maintainer.
func (m *HostMutation) RemovedMaintainerIDs() (ids []int) {
	for id := range m.removedmaintainer {
		ids = append(ids, id)
	}
	return
}

// MaintainerIDs returns the maintainer ids in the mutation.
func (m *HostMutation) MaintainerIDs() (ids []int) {
	for id := range m.maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetMaintainer reset all changes of the "maintainer" edge.
func (m *HostMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
	m.removedmaintainer = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *HostMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *HostMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *HostMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *HostMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *HostMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *HostMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *HostMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.description != nil {
		fields = append(fields, host.FieldDescription)
	}
	if m._OS != nil {
		fields = append(fields, host.FieldOS)
	}
	if m.last_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	if m.allow_mac_changes != nil {
		fields = append(fields, host.FieldAllowMACChanges)
	}
	if m.exposed_tcp_ports != nil {
		fields = append(fields, host.FieldExposedTCPPorts)
	}
	if m.exposed_udp_ports != nil {
		fields = append(fields, host.FieldExposedUDPPorts)
	}
	if m.override_password != nil {
		fields = append(fields, host.FieldOverridePassword)
	}
	if m.vars != nil {
		fields = append(fields, host.FieldVars)
	}
	if m.user_groups != nil {
		fields = append(fields, host.FieldUserGroups)
	}
	if m.depends_on != nil {
		fields = append(fields, host.FieldDependsOn)
	}
	if m.scripts != nil {
		fields = append(fields, host.FieldScripts)
	}
	if m.commands != nil {
		fields = append(fields, host.FieldCommands)
	}
	if m.remote_files != nil {
		fields = append(fields, host.FieldRemoteFiles)
	}
	if m.dns_records != nil {
		fields = append(fields, host.FieldDNSRecords)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldDescription:
		return m.Description()
	case host.FieldOS:
		return m.OS()
	case host.FieldLastOctet:
		return m.LastOctet()
	case host.FieldAllowMACChanges:
		return m.AllowMACChanges()
	case host.FieldExposedTCPPorts:
		return m.ExposedTCPPorts()
	case host.FieldExposedUDPPorts:
		return m.ExposedUDPPorts()
	case host.FieldOverridePassword:
		return m.OverridePassword()
	case host.FieldVars:
		return m.Vars()
	case host.FieldUserGroups:
		return m.UserGroups()
	case host.FieldDependsOn:
		return m.DependsOn()
	case host.FieldScripts:
		return m.Scripts()
	case host.FieldCommands:
		return m.Commands()
	case host.FieldRemoteFiles:
		return m.RemoteFiles()
	case host.FieldDNSRecords:
		return m.DNSRecords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldDescription:
		return m.OldDescription(ctx)
	case host.FieldOS:
		return m.OldOS(ctx)
	case host.FieldLastOctet:
		return m.OldLastOctet(ctx)
	case host.FieldAllowMACChanges:
		return m.OldAllowMACChanges(ctx)
	case host.FieldExposedTCPPorts:
		return m.OldExposedTCPPorts(ctx)
	case host.FieldExposedUDPPorts:
		return m.OldExposedUDPPorts(ctx)
	case host.FieldOverridePassword:
		return m.OldOverridePassword(ctx)
	case host.FieldVars:
		return m.OldVars(ctx)
	case host.FieldUserGroups:
		return m.OldUserGroups(ctx)
	case host.FieldDependsOn:
		return m.OldDependsOn(ctx)
	case host.FieldScripts:
		return m.OldScripts(ctx)
	case host.FieldCommands:
		return m.OldCommands(ctx)
	case host.FieldRemoteFiles:
		return m.OldRemoteFiles(ctx)
	case host.FieldDNSRecords:
		return m.OldDNSRecords(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case host.FieldOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOS(v)
		return nil
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOctet(v)
		return nil
	case host.FieldAllowMACChanges:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowMACChanges(v)
		return nil
	case host.FieldExposedTCPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedTCPPorts(v)
		return nil
	case host.FieldExposedUDPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedUDPPorts(v)
		return nil
	case host.FieldOverridePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePassword(v)
		return nil
	case host.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case host.FieldUserGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserGroups(v)
		return nil
	case host.FieldDependsOn:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependsOn(v)
		return nil
	case host.FieldScripts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScripts(v)
		return nil
	case host.FieldCommands:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommands(v)
		return nil
	case host.FieldRemoteFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteFiles(v)
		return nil
	case host.FieldDNSRecords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSRecords(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	if m.addlast_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case host.FieldLastOctet:
		return m.AddedLastOctet()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastOctet(v)
		return nil
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldDependsOn) {
		fields = append(fields, host.FieldDependsOn)
	}
	if m.FieldCleared(host.FieldScripts) {
		fields = append(fields, host.FieldScripts)
	}
	if m.FieldCleared(host.FieldCommands) {
		fields = append(fields, host.FieldCommands)
	}
	if m.FieldCleared(host.FieldRemoteFiles) {
		fields = append(fields, host.FieldRemoteFiles)
	}
	if m.FieldCleared(host.FieldDNSRecords) {
		fields = append(fields, host.FieldDNSRecords)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldDependsOn:
		m.ClearDependsOn()
		return nil
	case host.FieldScripts:
		m.ClearScripts()
		return nil
	case host.FieldCommands:
		m.ClearCommands()
		return nil
	case host.FieldRemoteFiles:
		m.ClearRemoteFiles()
		return nil
	case host.FieldDNSRecords:
		m.ClearDNSRecords()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldDescription:
		m.ResetDescription()
		return nil
	case host.FieldOS:
		m.ResetOS()
		return nil
	case host.FieldLastOctet:
		m.ResetLastOctet()
		return nil
	case host.FieldAllowMACChanges:
		m.ResetAllowMACChanges()
		return nil
	case host.FieldExposedTCPPorts:
		m.ResetExposedTCPPorts()
		return nil
	case host.FieldExposedUDPPorts:
		m.ResetExposedUDPPorts()
		return nil
	case host.FieldOverridePassword:
		m.ResetOverridePassword()
		return nil
	case host.FieldVars:
		m.ResetVars()
		return nil
	case host.FieldUserGroups:
		m.ResetUserGroups()
		return nil
	case host.FieldDependsOn:
		m.ResetDependsOn()
		return nil
	case host.FieldScripts:
		m.ResetScripts()
		return nil
	case host.FieldCommands:
		m.ResetCommands()
		return nil
	case host.FieldRemoteFiles:
		m.ResetRemoteFiles()
		return nil
	case host.FieldDNSRecords:
		m.ResetDNSRecords()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.disk != nil {
		edges = append(edges, host.EdgeDisk)
	}
	if m.maintainer != nil {
		edges = append(edges, host.EdgeMaintainer)
	}
	if m.tag != nil {
		edges = append(edges, host.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeDisk:
		ids := make([]ent.Value, 0, len(m.disk))
		for id := range m.disk {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.maintainer))
		for id := range m.maintainer {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddisk != nil {
		edges = append(edges, host.EdgeDisk)
	}
	if m.removedmaintainer != nil {
		edges = append(edges, host.EdgeMaintainer)
	}
	if m.removedtag != nil {
		edges = append(edges, host.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeDisk:
		ids := make([]ent.Value, 0, len(m.removeddisk))
		for id := range m.removeddisk {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.removedmaintainer))
		for id := range m.removedmaintainer {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddisk {
		edges = append(edges, host.EdgeDisk)
	}
	if m.clearedmaintainer {
		edges = append(edges, host.EdgeMaintainer)
	}
	if m.clearedtag {
		edges = append(edges, host.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeDisk:
		return m.cleareddisk
	case host.EdgeMaintainer:
		return m.clearedmaintainer
	case host.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeDisk:
		m.ResetDisk()
		return nil
	case host.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	case host.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// IncludedNetworkMutation represents an operation that mutate the IncludedNetworks
// nodes in the graph.
type IncludedNetworkMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	name                                 *string
	hosts                                *[]string
	clearedFields                        map[string]struct{}
	tag                                  map[int]struct{}
	removedtag                           map[int]struct{}
	clearedtag                           bool
	_IncludedNetworkToEnvironment        map[int]struct{}
	removed_IncludedNetworkToEnvironment map[int]struct{}
	cleared_IncludedNetworkToEnvironment bool
	done                                 bool
	oldValue                             func(context.Context) (*IncludedNetwork, error)
	predicates                           []predicate.IncludedNetwork
}

var _ ent.Mutation = (*IncludedNetworkMutation)(nil)

// includednetworkOption allows to manage the mutation configuration using functional options.
type includednetworkOption func(*IncludedNetworkMutation)

// newIncludedNetworkMutation creates new mutation for IncludedNetwork.
func newIncludedNetworkMutation(c config, op Op, opts ...includednetworkOption) *IncludedNetworkMutation {
	m := &IncludedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeIncludedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncludedNetworkID sets the id field of the mutation.
func withIncludedNetworkID(id int) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *IncludedNetwork
		)
		m.oldValue = func(ctx context.Context) (*IncludedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncludedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncludedNetwork sets the old IncludedNetwork of the mutation.
func withIncludedNetwork(node *IncludedNetwork) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		m.oldValue = func(context.Context) (*IncludedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncludedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncludedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *IncludedNetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *IncludedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *IncludedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the IncludedNetwork.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *IncludedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *IncludedNetworkMutation) ResetName() {
	m.name = nil
}

// SetHosts sets the hosts field.
func (m *IncludedNetworkMutation) SetHosts(s []string) {
	m.hosts = &s
}

// Hosts returns the hosts value in the mutation.
func (m *IncludedNetworkMutation) Hosts() (r []string, exists bool) {
	v := m.hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldHosts returns the old hosts value of the IncludedNetwork.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *IncludedNetworkMutation) OldHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHosts is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHosts: %w", err)
	}
	return oldValue.Hosts, nil
}

// ResetHosts reset all changes of the "hosts" field.
func (m *IncludedNetworkMutation) ResetHosts() {
	m.hosts = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *IncludedNetworkMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *IncludedNetworkMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *IncludedNetworkMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *IncludedNetworkMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *IncludedNetworkMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *IncludedNetworkMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *IncludedNetworkMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddIncludedNetworkToEnvironmentIDs adds the IncludedNetworkToEnvironment edge to Environment by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToEnvironmentIDs(ids ...int) {
	if m._IncludedNetworkToEnvironment == nil {
		m._IncludedNetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToEnvironment clears the IncludedNetworkToEnvironment edge to Environment.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToEnvironment() {
	m.cleared_IncludedNetworkToEnvironment = true
}

// IncludedNetworkToEnvironmentCleared returns if the edge IncludedNetworkToEnvironment was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToEnvironmentCleared() bool {
	return m.cleared_IncludedNetworkToEnvironment
}

// RemoveIncludedNetworkToEnvironmentIDs removes the IncludedNetworkToEnvironment edge to Environment by ids.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToEnvironmentIDs(ids ...int) {
	if m.removed_IncludedNetworkToEnvironment == nil {
		m.removed_IncludedNetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_IncludedNetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToEnvironment returns the removed ids of IncludedNetworkToEnvironment.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToEnvironmentIDs() (ids []int) {
	for id := range m.removed_IncludedNetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToEnvironmentIDs returns the IncludedNetworkToEnvironment ids in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToEnvironmentIDs() (ids []int) {
	for id := range m._IncludedNetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToEnvironment reset all changes of the "IncludedNetworkToEnvironment" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToEnvironment() {
	m._IncludedNetworkToEnvironment = nil
	m.cleared_IncludedNetworkToEnvironment = false
	m.removed_IncludedNetworkToEnvironment = nil
}

// Op returns the operation name.
func (m *IncludedNetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (IncludedNetwork).
func (m *IncludedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *IncludedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, includednetwork.FieldName)
	}
	if m.hosts != nil {
		fields = append(fields, includednetwork.FieldHosts)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *IncludedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case includednetwork.FieldName:
		return m.Name()
	case includednetwork.FieldHosts:
		return m.Hosts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *IncludedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case includednetwork.FieldName:
		return m.OldName(ctx)
	case includednetwork.FieldHosts:
		return m.OldHosts(ctx)
	}
	return nil, fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *IncludedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case includednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case includednetwork.FieldHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHosts(v)
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *IncludedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *IncludedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *IncludedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncludedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *IncludedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *IncludedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncludedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *IncludedNetworkMutation) ResetField(name string) error {
	switch name {
	case includednetwork.FieldName:
		m.ResetName()
		return nil
	case includednetwork.FieldHosts:
		m.ResetHosts()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *IncludedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, includednetwork.EdgeTag)
	}
	if m._IncludedNetworkToEnvironment != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *IncludedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToEnvironment))
		for id := range m._IncludedNetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *IncludedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtag != nil {
		edges = append(edges, includednetwork.EdgeTag)
	}
	if m.removed_IncludedNetworkToEnvironment != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *IncludedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToEnvironment))
		for id := range m.removed_IncludedNetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *IncludedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, includednetwork.EdgeTag)
	}
	if m.cleared_IncludedNetworkToEnvironment {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *IncludedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case includednetwork.EdgeTag:
		return m.clearedtag
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		return m.cleared_IncludedNetworkToEnvironment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *IncludedNetworkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncludedNetwork unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *IncludedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case includednetwork.EdgeTag:
		m.ResetTag()
		return nil
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		m.ResetIncludedNetworkToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork edge %s", name)
}

// NetworkMutation represents an operation that mutate the Networks
// nodes in the graph.
type NetworkMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	cidr                         *string
	vdi_visible                  *bool
	vars                         *map[string]string
	clearedFields                map[string]struct{}
	tag                          map[int]struct{}
	removedtag                   map[int]struct{}
	clearedtag                   bool
	_NetworkToEnvironment        map[int]struct{}
	removed_NetworkToEnvironment map[int]struct{}
	cleared_NetworkToEnvironment bool
	done                         bool
	oldValue                     func(context.Context) (*Network, error)
	predicates                   []predicate.Network
}

var _ ent.Mutation = (*NetworkMutation)(nil)

// networkOption allows to manage the mutation configuration using functional options.
type networkOption func(*NetworkMutation)

// newNetworkMutation creates new mutation for Network.
func newNetworkMutation(c config, op Op, opts ...networkOption) *NetworkMutation {
	m := &NetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkID sets the id field of the mutation.
func withNetworkID(id int) networkOption {
	return func(m *NetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Network
		)
		m.oldValue = func(ctx context.Context) (*Network, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Network.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetwork sets the old Network of the mutation.
func withNetwork(node *Network) networkOption {
	return func(m *NetworkMutation) {
		m.oldValue = func(context.Context) (*Network, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *NetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *NetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Network.
// If the Network object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *NetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the cidr field.
func (m *NetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the cidr value in the mutation.
func (m *NetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old cidr value of the Network.
// If the Network object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCidr is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr reset all changes of the "cidr" field.
func (m *NetworkMutation) ResetCidr() {
	m.cidr = nil
}

// SetVdiVisible sets the vdi_visible field.
func (m *NetworkMutation) SetVdiVisible(b bool) {
	m.vdi_visible = &b
}

// VdiVisible returns the vdi_visible value in the mutation.
func (m *NetworkMutation) VdiVisible() (r bool, exists bool) {
	v := m.vdi_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVdiVisible returns the old vdi_visible value of the Network.
// If the Network object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkMutation) OldVdiVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVdiVisible is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVdiVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVdiVisible: %w", err)
	}
	return oldValue.VdiVisible, nil
}

// ResetVdiVisible reset all changes of the "vdi_visible" field.
func (m *NetworkMutation) ResetVdiVisible() {
	m.vdi_visible = nil
}

// SetVars sets the vars field.
func (m *NetworkMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the vars value in the mutation.
func (m *NetworkMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old vars value of the Network.
// If the Network object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars reset all changes of the "vars" field.
func (m *NetworkMutation) ResetVars() {
	m.vars = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *NetworkMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *NetworkMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *NetworkMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *NetworkMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *NetworkMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *NetworkMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *NetworkMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddNetworkToEnvironmentIDs adds the NetworkToEnvironment edge to Environment by ids.
func (m *NetworkMutation) AddNetworkToEnvironmentIDs(ids ...int) {
	if m._NetworkToEnvironment == nil {
		m._NetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._NetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearNetworkToEnvironment clears the NetworkToEnvironment edge to Environment.
func (m *NetworkMutation) ClearNetworkToEnvironment() {
	m.cleared_NetworkToEnvironment = true
}

// NetworkToEnvironmentCleared returns if the edge NetworkToEnvironment was cleared.
func (m *NetworkMutation) NetworkToEnvironmentCleared() bool {
	return m.cleared_NetworkToEnvironment
}

// RemoveNetworkToEnvironmentIDs removes the NetworkToEnvironment edge to Environment by ids.
func (m *NetworkMutation) RemoveNetworkToEnvironmentIDs(ids ...int) {
	if m.removed_NetworkToEnvironment == nil {
		m.removed_NetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToEnvironment returns the removed ids of NetworkToEnvironment.
func (m *NetworkMutation) RemovedNetworkToEnvironmentIDs() (ids []int) {
	for id := range m.removed_NetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// NetworkToEnvironmentIDs returns the NetworkToEnvironment ids in the mutation.
func (m *NetworkMutation) NetworkToEnvironmentIDs() (ids []int) {
	for id := range m._NetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToEnvironment reset all changes of the "NetworkToEnvironment" edge.
func (m *NetworkMutation) ResetNetworkToEnvironment() {
	m._NetworkToEnvironment = nil
	m.cleared_NetworkToEnvironment = false
	m.removed_NetworkToEnvironment = nil
}

// Op returns the operation name.
func (m *NetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Network).
func (m *NetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NetworkMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, network.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, network.FieldCidr)
	}
	if m.vdi_visible != nil {
		fields = append(fields, network.FieldVdiVisible)
	}
	if m.vars != nil {
		fields = append(fields, network.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case network.FieldName:
		return m.Name()
	case network.FieldCidr:
		return m.Cidr()
	case network.FieldVdiVisible:
		return m.VdiVisible()
	case network.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case network.FieldName:
		return m.OldName(ctx)
	case network.FieldCidr:
		return m.OldCidr(ctx)
	case network.FieldVdiVisible:
		return m.OldVdiVisible(ctx)
	case network.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown Network field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case network.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case network.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case network.FieldVdiVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVdiVisible(v)
		return nil
	case network.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Network numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Network nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NetworkMutation) ResetField(name string) error {
	switch name {
	case network.FieldName:
		m.ResetName()
		return nil
	case network.FieldCidr:
		m.ResetCidr()
		return nil
	case network.FieldVdiVisible:
		m.ResetVdiVisible()
		return nil
	case network.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, network.EdgeTag)
	}
	if m._NetworkToEnvironment != nil {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m._NetworkToEnvironment))
		for id := range m._NetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtag != nil {
		edges = append(edges, network.EdgeTag)
	}
	if m.removed_NetworkToEnvironment != nil {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToEnvironment))
		for id := range m.removed_NetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, network.EdgeTag)
	}
	if m.cleared_NetworkToEnvironment {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case network.EdgeTag:
		return m.clearedtag
	case network.EdgeNetworkToEnvironment:
		return m.cleared_NetworkToEnvironment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NetworkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Network unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NetworkMutation) ResetEdge(name string) error {
	switch name {
	case network.EdgeTag:
		m.ResetTag()
		return nil
	case network.EdgeNetworkToEnvironment:
		m.ResetNetworkToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Network edge %s", name)
}

// ProvisionedHostMutation represents an operation that mutate the ProvisionedHosts
// nodes in the graph.
type ProvisionedHostMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	subnet_ip                  *string
	clearedFields              map[string]struct{}
	status                     map[int]struct{}
	removedstatus              map[int]struct{}
	clearedstatus              bool
	provisioned_network        map[int]struct{}
	removedprovisioned_network map[int]struct{}
	clearedprovisioned_network bool
	host                       map[int]struct{}
	removedhost                map[int]struct{}
	clearedhost                bool
	provisioned_steps          map[int]struct{}
	removedprovisioned_steps   map[int]struct{}
	clearedprovisioned_steps   bool
	done                       bool
	oldValue                   func(context.Context) (*ProvisionedHost, error)
	predicates                 []predicate.ProvisionedHost
}

var _ ent.Mutation = (*ProvisionedHostMutation)(nil)

// provisionedhostOption allows to manage the mutation configuration using functional options.
type provisionedhostOption func(*ProvisionedHostMutation)

// newProvisionedHostMutation creates new mutation for ProvisionedHost.
func newProvisionedHostMutation(c config, op Op, opts ...provisionedhostOption) *ProvisionedHostMutation {
	m := &ProvisionedHostMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedHostID sets the id field of the mutation.
func withProvisionedHostID(id int) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedHost
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedHost, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedHost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedHost sets the old ProvisionedHost of the mutation.
func withProvisionedHost(node *ProvisionedHost) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		m.oldValue = func(context.Context) (*ProvisionedHost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedHostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedHostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProvisionedHostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubnetIP sets the subnet_ip field.
func (m *ProvisionedHostMutation) SetSubnetIP(s string) {
	m.subnet_ip = &s
}

// SubnetIP returns the subnet_ip value in the mutation.
func (m *ProvisionedHostMutation) SubnetIP() (r string, exists bool) {
	v := m.subnet_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnetIP returns the old subnet_ip value of the ProvisionedHost.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvisionedHostMutation) OldSubnetIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubnetIP is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubnetIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnetIP: %w", err)
	}
	return oldValue.SubnetIP, nil
}

// ResetSubnetIP reset all changes of the "subnet_ip" field.
func (m *ProvisionedHostMutation) ResetSubnetIP() {
	m.subnet_ip = nil
}

// AddStatuIDs adds the status edge to Status by ids.
func (m *ProvisionedHostMutation) AddStatuIDs(ids ...int) {
	if m.status == nil {
		m.status = make(map[int]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the status edge to Status.
func (m *ProvisionedHostMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared returns if the edge status was cleared.
func (m *ProvisionedHostMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the status edge to Status by ids.
func (m *ProvisionedHostMutation) RemoveStatuIDs(ids ...int) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed ids of status.
func (m *ProvisionedHostMutation) RemovedStatusIDs() (ids []int) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the status ids in the mutation.
func (m *ProvisionedHostMutation) StatusIDs() (ids []int) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus reset all changes of the "status" edge.
func (m *ProvisionedHostMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// AddProvisionedNetworkIDs adds the provisioned_network edge to ProvisionedNetwork by ids.
func (m *ProvisionedHostMutation) AddProvisionedNetworkIDs(ids ...int) {
	if m.provisioned_network == nil {
		m.provisioned_network = make(map[int]struct{})
	}
	for i := range ids {
		m.provisioned_network[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetwork clears the provisioned_network edge to ProvisionedNetwork.
func (m *ProvisionedHostMutation) ClearProvisionedNetwork() {
	m.clearedprovisioned_network = true
}

// ProvisionedNetworkCleared returns if the edge provisioned_network was cleared.
func (m *ProvisionedHostMutation) ProvisionedNetworkCleared() bool {
	return m.clearedprovisioned_network
}

// RemoveProvisionedNetworkIDs removes the provisioned_network edge to ProvisionedNetwork by ids.
func (m *ProvisionedHostMutation) RemoveProvisionedNetworkIDs(ids ...int) {
	if m.removedprovisioned_network == nil {
		m.removedprovisioned_network = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovisioned_network[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetwork returns the removed ids of provisioned_network.
func (m *ProvisionedHostMutation) RemovedProvisionedNetworkIDs() (ids []int) {
	for id := range m.removedprovisioned_network {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkIDs returns the provisioned_network ids in the mutation.
func (m *ProvisionedHostMutation) ProvisionedNetworkIDs() (ids []int) {
	for id := range m.provisioned_network {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetwork reset all changes of the "provisioned_network" edge.
func (m *ProvisionedHostMutation) ResetProvisionedNetwork() {
	m.provisioned_network = nil
	m.clearedprovisioned_network = false
	m.removedprovisioned_network = nil
}

// AddHostIDs adds the host edge to Host by ids.
func (m *ProvisionedHostMutation) AddHostIDs(ids ...int) {
	if m.host == nil {
		m.host = make(map[int]struct{})
	}
	for i := range ids {
		m.host[ids[i]] = struct{}{}
	}
}

// ClearHost clears the host edge to Host.
func (m *ProvisionedHostMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared returns if the edge host was cleared.
func (m *ProvisionedHostMutation) HostCleared() bool {
	return m.clearedhost
}

// RemoveHostIDs removes the host edge to Host by ids.
func (m *ProvisionedHostMutation) RemoveHostIDs(ids ...int) {
	if m.removedhost == nil {
		m.removedhost = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhost[ids[i]] = struct{}{}
	}
}

// RemovedHost returns the removed ids of host.
func (m *ProvisionedHostMutation) RemovedHostIDs() (ids []int) {
	for id := range m.removedhost {
		ids = append(ids, id)
	}
	return
}

// HostIDs returns the host ids in the mutation.
func (m *ProvisionedHostMutation) HostIDs() (ids []int) {
	for id := range m.host {
		ids = append(ids, id)
	}
	return
}

// ResetHost reset all changes of the "host" edge.
func (m *ProvisionedHostMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
	m.removedhost = nil
}

// AddProvisionedStepIDs adds the provisioned_steps edge to ProvisioningStep by ids.
func (m *ProvisionedHostMutation) AddProvisionedStepIDs(ids ...int) {
	if m.provisioned_steps == nil {
		m.provisioned_steps = make(map[int]struct{})
	}
	for i := range ids {
		m.provisioned_steps[ids[i]] = struct{}{}
	}
}

// ClearProvisionedSteps clears the provisioned_steps edge to ProvisioningStep.
func (m *ProvisionedHostMutation) ClearProvisionedSteps() {
	m.clearedprovisioned_steps = true
}

// ProvisionedStepsCleared returns if the edge provisioned_steps was cleared.
func (m *ProvisionedHostMutation) ProvisionedStepsCleared() bool {
	return m.clearedprovisioned_steps
}

// RemoveProvisionedStepIDs removes the provisioned_steps edge to ProvisioningStep by ids.
func (m *ProvisionedHostMutation) RemoveProvisionedStepIDs(ids ...int) {
	if m.removedprovisioned_steps == nil {
		m.removedprovisioned_steps = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovisioned_steps[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedSteps returns the removed ids of provisioned_steps.
func (m *ProvisionedHostMutation) RemovedProvisionedStepsIDs() (ids []int) {
	for id := range m.removedprovisioned_steps {
		ids = append(ids, id)
	}
	return
}

// ProvisionedStepsIDs returns the provisioned_steps ids in the mutation.
func (m *ProvisionedHostMutation) ProvisionedStepsIDs() (ids []int) {
	for id := range m.provisioned_steps {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedSteps reset all changes of the "provisioned_steps" edge.
func (m *ProvisionedHostMutation) ResetProvisionedSteps() {
	m.provisioned_steps = nil
	m.clearedprovisioned_steps = false
	m.removedprovisioned_steps = nil
}

// Op returns the operation name.
func (m *ProvisionedHostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisionedHost).
func (m *ProvisionedHostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProvisionedHostMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.subnet_ip != nil {
		fields = append(fields, provisionedhost.FieldSubnetIP)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProvisionedHostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.SubnetIP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProvisionedHostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.OldSubnetIP(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvisionedHostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnetIP(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProvisionedHostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProvisionedHostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvisionedHostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedHost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProvisionedHostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProvisionedHostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisionedHost nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProvisionedHostMutation) ResetField(name string) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		m.ResetSubnetIP()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProvisionedHostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.status != nil {
		edges = append(edges, provisionedhost.EdgeStatus)
	}
	if m.provisioned_network != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedNetwork)
	}
	if m.host != nil {
		edges = append(edges, provisionedhost.EdgeHost)
	}
	if m.provisioned_steps != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedSteps)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProvisionedHostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.provisioned_network))
		for id := range m.provisioned_network {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeHost:
		ids := make([]ent.Value, 0, len(m.host))
		for id := range m.host {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedSteps:
		ids := make([]ent.Value, 0, len(m.provisioned_steps))
		for id := range m.provisioned_steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProvisionedHostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedstatus != nil {
		edges = append(edges, provisionedhost.EdgeStatus)
	}
	if m.removedprovisioned_network != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedNetwork)
	}
	if m.removedhost != nil {
		edges = append(edges, provisionedhost.EdgeHost)
	}
	if m.removedprovisioned_steps != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedSteps)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProvisionedHostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.removedprovisioned_network))
		for id := range m.removedprovisioned_network {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeHost:
		ids := make([]ent.Value, 0, len(m.removedhost))
		for id := range m.removedhost {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedSteps:
		ids := make([]ent.Value, 0, len(m.removedprovisioned_steps))
		for id := range m.removedprovisioned_steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProvisionedHostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedstatus {
		edges = append(edges, provisionedhost.EdgeStatus)
	}
	if m.clearedprovisioned_network {
		edges = append(edges, provisionedhost.EdgeProvisionedNetwork)
	}
	if m.clearedhost {
		edges = append(edges, provisionedhost.EdgeHost)
	}
	if m.clearedprovisioned_steps {
		edges = append(edges, provisionedhost.EdgeProvisionedSteps)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProvisionedHostMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionedhost.EdgeStatus:
		return m.clearedstatus
	case provisionedhost.EdgeProvisionedNetwork:
		return m.clearedprovisioned_network
	case provisionedhost.EdgeHost:
		return m.clearedhost
	case provisionedhost.EdgeProvisionedSteps:
		return m.clearedprovisioned_steps
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProvisionedHostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedHost unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProvisionedHostMutation) ResetEdge(name string) error {
	switch name {
	case provisionedhost.EdgeStatus:
		m.ResetStatus()
		return nil
	case provisionedhost.EdgeProvisionedNetwork:
		m.ResetProvisionedNetwork()
		return nil
	case provisionedhost.EdgeHost:
		m.ResetHost()
		return nil
	case provisionedhost.EdgeProvisionedSteps:
		m.ResetProvisionedSteps()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost edge %s", name)
}

// ProvisionedNetworkMutation represents an operation that mutate the ProvisionedNetworks
// nodes in the graph.
type ProvisionedNetworkMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	name                             *string
	cidr                             *string
	clearedFields                    map[string]struct{}
	status                           map[int]struct{}
	removedstatus                    map[int]struct{}
	clearedstatus                    bool
	network                          map[int]struct{}
	removednetwork                   map[int]struct{}
	clearednetwork                   bool
	build                            map[int]struct{}
	removedbuild                     map[int]struct{}
	clearedbuild                     bool
	_ProvisionedNetworkToTeam        map[int]struct{}
	removed_ProvisionedNetworkToTeam map[int]struct{}
	cleared_ProvisionedNetworkToTeam bool
	provisioned_hosts                map[int]struct{}
	removedprovisioned_hosts         map[int]struct{}
	clearedprovisioned_hosts         bool
	done                             bool
	oldValue                         func(context.Context) (*ProvisionedNetwork, error)
	predicates                       []predicate.ProvisionedNetwork
}

var _ ent.Mutation = (*ProvisionedNetworkMutation)(nil)

// provisionednetworkOption allows to manage the mutation configuration using functional options.
type provisionednetworkOption func(*ProvisionedNetworkMutation)

// newProvisionedNetworkMutation creates new mutation for ProvisionedNetwork.
func newProvisionedNetworkMutation(c config, op Op, opts ...provisionednetworkOption) *ProvisionedNetworkMutation {
	m := &ProvisionedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedNetworkID sets the id field of the mutation.
func withProvisionedNetworkID(id int) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedNetwork
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedNetwork sets the old ProvisionedNetwork of the mutation.
func withProvisionedNetwork(node *ProvisionedNetwork) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		m.oldValue = func(context.Context) (*ProvisionedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProvisionedNetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ProvisionedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProvisionedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ProvisionedNetwork.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvisionedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProvisionedNetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the cidr field.
func (m *ProvisionedNetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the cidr value in the mutation.
func (m *ProvisionedNetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old cidr value of the ProvisionedNetwork.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvisionedNetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCidr is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr reset all changes of the "cidr" field.
func (m *ProvisionedNetworkMutation) ResetCidr() {
	m.cidr = nil
}

// AddStatuIDs adds the status edge to Status by ids.
func (m *ProvisionedNetworkMutation) AddStatuIDs(ids ...int) {
	if m.status == nil {
		m.status = make(map[int]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the status edge to Status.
func (m *ProvisionedNetworkMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared returns if the edge status was cleared.
func (m *ProvisionedNetworkMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the status edge to Status by ids.
func (m *ProvisionedNetworkMutation) RemoveStatuIDs(ids ...int) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed ids of status.
func (m *ProvisionedNetworkMutation) RemovedStatusIDs() (ids []int) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the status ids in the mutation.
func (m *ProvisionedNetworkMutation) StatusIDs() (ids []int) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus reset all changes of the "status" edge.
func (m *ProvisionedNetworkMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// AddNetworkIDs adds the network edge to Network by ids.
func (m *ProvisionedNetworkMutation) AddNetworkIDs(ids ...int) {
	if m.network == nil {
		m.network = make(map[int]struct{})
	}
	for i := range ids {
		m.network[ids[i]] = struct{}{}
	}
}

// ClearNetwork clears the network edge to Network.
func (m *ProvisionedNetworkMutation) ClearNetwork() {
	m.clearednetwork = true
}

// NetworkCleared returns if the edge network was cleared.
func (m *ProvisionedNetworkMutation) NetworkCleared() bool {
	return m.clearednetwork
}

// RemoveNetworkIDs removes the network edge to Network by ids.
func (m *ProvisionedNetworkMutation) RemoveNetworkIDs(ids ...int) {
	if m.removednetwork == nil {
		m.removednetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removednetwork[ids[i]] = struct{}{}
	}
}

// RemovedNetwork returns the removed ids of network.
func (m *ProvisionedNetworkMutation) RemovedNetworkIDs() (ids []int) {
	for id := range m.removednetwork {
		ids = append(ids, id)
	}
	return
}

// NetworkIDs returns the network ids in the mutation.
func (m *ProvisionedNetworkMutation) NetworkIDs() (ids []int) {
	for id := range m.network {
		ids = append(ids, id)
	}
	return
}

// ResetNetwork reset all changes of the "network" edge.
func (m *ProvisionedNetworkMutation) ResetNetwork() {
	m.network = nil
	m.clearednetwork = false
	m.removednetwork = nil
}

// AddBuildIDs adds the build edge to Build by ids.
func (m *ProvisionedNetworkMutation) AddBuildIDs(ids ...int) {
	if m.build == nil {
		m.build = make(map[int]struct{})
	}
	for i := range ids {
		m.build[ids[i]] = struct{}{}
	}
}

// ClearBuild clears the build edge to Build.
func (m *ProvisionedNetworkMutation) ClearBuild() {
	m.clearedbuild = true
}

// BuildCleared returns if the edge build was cleared.
func (m *ProvisionedNetworkMutation) BuildCleared() bool {
	return m.clearedbuild
}

// RemoveBuildIDs removes the build edge to Build by ids.
func (m *ProvisionedNetworkMutation) RemoveBuildIDs(ids ...int) {
	if m.removedbuild == nil {
		m.removedbuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbuild[ids[i]] = struct{}{}
	}
}

// RemovedBuild returns the removed ids of build.
func (m *ProvisionedNetworkMutation) RemovedBuildIDs() (ids []int) {
	for id := range m.removedbuild {
		ids = append(ids, id)
	}
	return
}

// BuildIDs returns the build ids in the mutation.
func (m *ProvisionedNetworkMutation) BuildIDs() (ids []int) {
	for id := range m.build {
		ids = append(ids, id)
	}
	return
}

// ResetBuild reset all changes of the "build" edge.
func (m *ProvisionedNetworkMutation) ResetBuild() {
	m.build = nil
	m.clearedbuild = false
	m.removedbuild = nil
}

// AddProvisionedNetworkToTeamIDs adds the ProvisionedNetworkToTeam edge to Team by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToTeamIDs(ids ...int) {
	if m._ProvisionedNetworkToTeam == nil {
		m._ProvisionedNetworkToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToTeam[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToTeam clears the ProvisionedNetworkToTeam edge to Team.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToTeam() {
	m.cleared_ProvisionedNetworkToTeam = true
}

// ProvisionedNetworkToTeamCleared returns if the edge ProvisionedNetworkToTeam was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamCleared() bool {
	return m.cleared_ProvisionedNetworkToTeam
}

// RemoveProvisionedNetworkToTeamIDs removes the ProvisionedNetworkToTeam edge to Team by ids.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToTeamIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToTeam == nil {
		m.removed_ProvisionedNetworkToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToTeam[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToTeam returns the removed ids of ProvisionedNetworkToTeam.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToTeamIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToTeam {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToTeamIDs returns the ProvisionedNetworkToTeam ids in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToTeam {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToTeam reset all changes of the "ProvisionedNetworkToTeam" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToTeam() {
	m._ProvisionedNetworkToTeam = nil
	m.cleared_ProvisionedNetworkToTeam = false
	m.removed_ProvisionedNetworkToTeam = nil
}

// AddProvisionedHostIDs adds the provisioned_hosts edge to ProvisionedHost by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedHostIDs(ids ...int) {
	if m.provisioned_hosts == nil {
		m.provisioned_hosts = make(map[int]struct{})
	}
	for i := range ids {
		m.provisioned_hosts[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHosts clears the provisioned_hosts edge to ProvisionedHost.
func (m *ProvisionedNetworkMutation) ClearProvisionedHosts() {
	m.clearedprovisioned_hosts = true
}

// ProvisionedHostsCleared returns if the edge provisioned_hosts was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedHostsCleared() bool {
	return m.clearedprovisioned_hosts
}

// RemoveProvisionedHostIDs removes the provisioned_hosts edge to ProvisionedHost by ids.
func (m *ProvisionedNetworkMutation) RemoveProvisionedHostIDs(ids ...int) {
	if m.removedprovisioned_hosts == nil {
		m.removedprovisioned_hosts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovisioned_hosts[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHosts returns the removed ids of provisioned_hosts.
func (m *ProvisionedNetworkMutation) RemovedProvisionedHostsIDs() (ids []int) {
	for id := range m.removedprovisioned_hosts {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostsIDs returns the provisioned_hosts ids in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedHostsIDs() (ids []int) {
	for id := range m.provisioned_hosts {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHosts reset all changes of the "provisioned_hosts" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedHosts() {
	m.provisioned_hosts = nil
	m.clearedprovisioned_hosts = false
	m.removedprovisioned_hosts = nil
}

// Op returns the operation name.
func (m *ProvisionedNetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisionedNetwork).
func (m *ProvisionedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProvisionedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, provisionednetwork.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, provisionednetwork.FieldCidr)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProvisionedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionednetwork.FieldName:
		return m.Name()
	case provisionednetwork.FieldCidr:
		return m.Cidr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProvisionedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionednetwork.FieldName:
		return m.OldName(ctx)
	case provisionednetwork.FieldCidr:
		return m.OldCidr(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvisionedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provisionednetwork.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProvisionedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProvisionedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvisionedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProvisionedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProvisionedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisionedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProvisionedNetworkMutation) ResetField(name string) error {
	switch name {
	case provisionednetwork.FieldName:
		m.ResetName()
		return nil
	case provisionednetwork.FieldCidr:
		m.ResetCidr()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProvisionedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.status != nil {
		edges = append(edges, provisionednetwork.EdgeStatus)
	}
	if m.network != nil {
		edges = append(edges, provisionednetwork.EdgeNetwork)
	}
	if m.build != nil {
		edges = append(edges, provisionednetwork.EdgeBuild)
	}
	if m._ProvisionedNetworkToTeam != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m.provisioned_hosts != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedHosts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProvisionedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeNetwork:
		ids := make([]ent.Value, 0, len(m.network))
		for id := range m.network {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeBuild:
		ids := make([]ent.Value, 0, len(m.build))
		for id := range m.build {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToTeam))
		for id := range m._ProvisionedNetworkToTeam {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedHosts:
		ids := make([]ent.Value, 0, len(m.provisioned_hosts))
		for id := range m.provisioned_hosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProvisionedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedstatus != nil {
		edges = append(edges, provisionednetwork.EdgeStatus)
	}
	if m.removednetwork != nil {
		edges = append(edges, provisionednetwork.EdgeNetwork)
	}
	if m.removedbuild != nil {
		edges = append(edges, provisionednetwork.EdgeBuild)
	}
	if m.removed_ProvisionedNetworkToTeam != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m.removedprovisioned_hosts != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedHosts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProvisionedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeNetwork:
		ids := make([]ent.Value, 0, len(m.removednetwork))
		for id := range m.removednetwork {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeBuild:
		ids := make([]ent.Value, 0, len(m.removedbuild))
		for id := range m.removedbuild {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToTeam))
		for id := range m.removed_ProvisionedNetworkToTeam {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedHosts:
		ids := make([]ent.Value, 0, len(m.removedprovisioned_hosts))
		for id := range m.removedprovisioned_hosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProvisionedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedstatus {
		edges = append(edges, provisionednetwork.EdgeStatus)
	}
	if m.clearednetwork {
		edges = append(edges, provisionednetwork.EdgeNetwork)
	}
	if m.clearedbuild {
		edges = append(edges, provisionednetwork.EdgeBuild)
	}
	if m.cleared_ProvisionedNetworkToTeam {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m.clearedprovisioned_hosts {
		edges = append(edges, provisionednetwork.EdgeProvisionedHosts)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProvisionedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionednetwork.EdgeStatus:
		return m.clearedstatus
	case provisionednetwork.EdgeNetwork:
		return m.clearednetwork
	case provisionednetwork.EdgeBuild:
		return m.clearedbuild
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		return m.cleared_ProvisionedNetworkToTeam
	case provisionednetwork.EdgeProvisionedHosts:
		return m.clearedprovisioned_hosts
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedNetwork unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProvisionedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case provisionednetwork.EdgeStatus:
		m.ResetStatus()
		return nil
	case provisionednetwork.EdgeNetwork:
		m.ResetNetwork()
		return nil
	case provisionednetwork.EdgeBuild:
		m.ResetBuild()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		m.ResetProvisionedNetworkToTeam()
		return nil
	case provisionednetwork.EdgeProvisionedHosts:
		m.ResetProvisionedHosts()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork edge %s", name)
}

// ProvisioningStepMutation represents an operation that mutate the ProvisioningSteps
// nodes in the graph.
type ProvisioningStepMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	provisioner_type        *string
	step_number             *int
	addstep_number          *int
	status                  *string
	clearedFields           map[string]struct{}
	provisioned_host        map[int]struct{}
	removedprovisioned_host map[int]struct{}
	clearedprovisioned_host bool
	script                  map[int]struct{}
	removedscript           map[int]struct{}
	clearedscript           bool
	command                 map[int]struct{}
	removedcommand          map[int]struct{}
	clearedcommand          bool
	dns_record              map[int]struct{}
	removeddns_record       map[int]struct{}
	cleareddns_record       bool
	remote_file             map[int]struct{}
	removedremote_file      map[int]struct{}
	clearedremote_file      bool
	done                    bool
	oldValue                func(context.Context) (*ProvisioningStep, error)
	predicates              []predicate.ProvisioningStep
}

var _ ent.Mutation = (*ProvisioningStepMutation)(nil)

// provisioningstepOption allows to manage the mutation configuration using functional options.
type provisioningstepOption func(*ProvisioningStepMutation)

// newProvisioningStepMutation creates new mutation for ProvisioningStep.
func newProvisioningStepMutation(c config, op Op, opts ...provisioningstepOption) *ProvisioningStepMutation {
	m := &ProvisioningStepMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisioningStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisioningStepID sets the id field of the mutation.
func withProvisioningStepID(id int) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisioningStep
		)
		m.oldValue = func(ctx context.Context) (*ProvisioningStep, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisioningStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisioningStep sets the old ProvisioningStep of the mutation.
func withProvisioningStep(node *ProvisioningStep) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		m.oldValue = func(context.Context) (*ProvisioningStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisioningStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisioningStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProvisioningStepMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvisionerType sets the provisioner_type field.
func (m *ProvisioningStepMutation) SetProvisionerType(s string) {
	m.provisioner_type = &s
}

// ProvisionerType returns the provisioner_type value in the mutation.
func (m *ProvisioningStepMutation) ProvisionerType() (r string, exists bool) {
	v := m.provisioner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProvisionerType returns the old provisioner_type value of the ProvisioningStep.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvisioningStepMutation) OldProvisionerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvisionerType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvisionerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvisionerType: %w", err)
	}
	return oldValue.ProvisionerType, nil
}

// ResetProvisionerType reset all changes of the "provisioner_type" field.
func (m *ProvisioningStepMutation) ResetProvisionerType() {
	m.provisioner_type = nil
}

// SetStepNumber sets the step_number field.
func (m *ProvisioningStepMutation) SetStepNumber(i int) {
	m.step_number = &i
	m.addstep_number = nil
}

// StepNumber returns the step_number value in the mutation.
func (m *ProvisioningStepMutation) StepNumber() (r int, exists bool) {
	v := m.step_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStepNumber returns the old step_number value of the ProvisioningStep.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvisioningStepMutation) OldStepNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStepNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStepNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepNumber: %w", err)
	}
	return oldValue.StepNumber, nil
}

// AddStepNumber adds i to step_number.
func (m *ProvisioningStepMutation) AddStepNumber(i int) {
	if m.addstep_number != nil {
		*m.addstep_number += i
	} else {
		m.addstep_number = &i
	}
}

// AddedStepNumber returns the value that was added to the step_number field in this mutation.
func (m *ProvisioningStepMutation) AddedStepNumber() (r int, exists bool) {
	v := m.addstep_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepNumber reset all changes of the "step_number" field.
func (m *ProvisioningStepMutation) ResetStepNumber() {
	m.step_number = nil
	m.addstep_number = nil
}

// SetStatus sets the status field.
func (m *ProvisioningStepMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the status value in the mutation.
func (m *ProvisioningStepMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the ProvisioningStep.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProvisioningStepMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *ProvisioningStepMutation) ResetStatus() {
	m.status = nil
}

// AddProvisionedHostIDs adds the provisioned_host edge to ProvisionedHost by ids.
func (m *ProvisioningStepMutation) AddProvisionedHostIDs(ids ...int) {
	if m.provisioned_host == nil {
		m.provisioned_host = make(map[int]struct{})
	}
	for i := range ids {
		m.provisioned_host[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHost clears the provisioned_host edge to ProvisionedHost.
func (m *ProvisioningStepMutation) ClearProvisionedHost() {
	m.clearedprovisioned_host = true
}

// ProvisionedHostCleared returns if the edge provisioned_host was cleared.
func (m *ProvisioningStepMutation) ProvisionedHostCleared() bool {
	return m.clearedprovisioned_host
}

// RemoveProvisionedHostIDs removes the provisioned_host edge to ProvisionedHost by ids.
func (m *ProvisioningStepMutation) RemoveProvisionedHostIDs(ids ...int) {
	if m.removedprovisioned_host == nil {
		m.removedprovisioned_host = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovisioned_host[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHost returns the removed ids of provisioned_host.
func (m *ProvisioningStepMutation) RemovedProvisionedHostIDs() (ids []int) {
	for id := range m.removedprovisioned_host {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostIDs returns the provisioned_host ids in the mutation.
func (m *ProvisioningStepMutation) ProvisionedHostIDs() (ids []int) {
	for id := range m.provisioned_host {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHost reset all changes of the "provisioned_host" edge.
func (m *ProvisioningStepMutation) ResetProvisionedHost() {
	m.provisioned_host = nil
	m.clearedprovisioned_host = false
	m.removedprovisioned_host = nil
}

// AddScriptIDs adds the script edge to Script by ids.
func (m *ProvisioningStepMutation) AddScriptIDs(ids ...int) {
	if m.script == nil {
		m.script = make(map[int]struct{})
	}
	for i := range ids {
		m.script[ids[i]] = struct{}{}
	}
}

// ClearScript clears the script edge to Script.
func (m *ProvisioningStepMutation) ClearScript() {
	m.clearedscript = true
}

// ScriptCleared returns if the edge script was cleared.
func (m *ProvisioningStepMutation) ScriptCleared() bool {
	return m.clearedscript
}

// RemoveScriptIDs removes the script edge to Script by ids.
func (m *ProvisioningStepMutation) RemoveScriptIDs(ids ...int) {
	if m.removedscript == nil {
		m.removedscript = make(map[int]struct{})
	}
	for i := range ids {
		m.removedscript[ids[i]] = struct{}{}
	}
}

// RemovedScript returns the removed ids of script.
func (m *ProvisioningStepMutation) RemovedScriptIDs() (ids []int) {
	for id := range m.removedscript {
		ids = append(ids, id)
	}
	return
}

// ScriptIDs returns the script ids in the mutation.
func (m *ProvisioningStepMutation) ScriptIDs() (ids []int) {
	for id := range m.script {
		ids = append(ids, id)
	}
	return
}

// ResetScript reset all changes of the "script" edge.
func (m *ProvisioningStepMutation) ResetScript() {
	m.script = nil
	m.clearedscript = false
	m.removedscript = nil
}

// AddCommandIDs adds the command edge to Command by ids.
func (m *ProvisioningStepMutation) AddCommandIDs(ids ...int) {
	if m.command == nil {
		m.command = make(map[int]struct{})
	}
	for i := range ids {
		m.command[ids[i]] = struct{}{}
	}
}

// ClearCommand clears the command edge to Command.
func (m *ProvisioningStepMutation) ClearCommand() {
	m.clearedcommand = true
}

// CommandCleared returns if the edge command was cleared.
func (m *ProvisioningStepMutation) CommandCleared() bool {
	return m.clearedcommand
}

// RemoveCommandIDs removes the command edge to Command by ids.
func (m *ProvisioningStepMutation) RemoveCommandIDs(ids ...int) {
	if m.removedcommand == nil {
		m.removedcommand = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcommand[ids[i]] = struct{}{}
	}
}

// RemovedCommand returns the removed ids of command.
func (m *ProvisioningStepMutation) RemovedCommandIDs() (ids []int) {
	for id := range m.removedcommand {
		ids = append(ids, id)
	}
	return
}

// CommandIDs returns the command ids in the mutation.
func (m *ProvisioningStepMutation) CommandIDs() (ids []int) {
	for id := range m.command {
		ids = append(ids, id)
	}
	return
}

// ResetCommand reset all changes of the "command" edge.
func (m *ProvisioningStepMutation) ResetCommand() {
	m.command = nil
	m.clearedcommand = false
	m.removedcommand = nil
}

// AddDNSRecordIDs adds the dns_record edge to DNSRecord by ids.
func (m *ProvisioningStepMutation) AddDNSRecordIDs(ids ...int) {
	if m.dns_record == nil {
		m.dns_record = make(map[int]struct{})
	}
	for i := range ids {
		m.dns_record[ids[i]] = struct{}{}
	}
}

// ClearDNSRecord clears the dns_record edge to DNSRecord.
func (m *ProvisioningStepMutation) ClearDNSRecord() {
	m.cleareddns_record = true
}

// DNSRecordCleared returns if the edge dns_record was cleared.
func (m *ProvisioningStepMutation) DNSRecordCleared() bool {
	return m.cleareddns_record
}

// RemoveDNSRecordIDs removes the dns_record edge to DNSRecord by ids.
func (m *ProvisioningStepMutation) RemoveDNSRecordIDs(ids ...int) {
	if m.removeddns_record == nil {
		m.removeddns_record = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddns_record[ids[i]] = struct{}{}
	}
}

// RemovedDNSRecord returns the removed ids of dns_record.
func (m *ProvisioningStepMutation) RemovedDNSRecordIDs() (ids []int) {
	for id := range m.removeddns_record {
		ids = append(ids, id)
	}
	return
}

// DNSRecordIDs returns the dns_record ids in the mutation.
func (m *ProvisioningStepMutation) DNSRecordIDs() (ids []int) {
	for id := range m.dns_record {
		ids = append(ids, id)
	}
	return
}

// ResetDNSRecord reset all changes of the "dns_record" edge.
func (m *ProvisioningStepMutation) ResetDNSRecord() {
	m.dns_record = nil
	m.cleareddns_record = false
	m.removeddns_record = nil
}

// AddRemoteFileIDs adds the remote_file edge to RemoteFile by ids.
func (m *ProvisioningStepMutation) AddRemoteFileIDs(ids ...int) {
	if m.remote_file == nil {
		m.remote_file = make(map[int]struct{})
	}
	for i := range ids {
		m.remote_file[ids[i]] = struct{}{}
	}
}

// ClearRemoteFile clears the remote_file edge to RemoteFile.
func (m *ProvisioningStepMutation) ClearRemoteFile() {
	m.clearedremote_file = true
}

// RemoteFileCleared returns if the edge remote_file was cleared.
func (m *ProvisioningStepMutation) RemoteFileCleared() bool {
	return m.clearedremote_file
}

// RemoveRemoteFileIDs removes the remote_file edge to RemoteFile by ids.
func (m *ProvisioningStepMutation) RemoveRemoteFileIDs(ids ...int) {
	if m.removedremote_file == nil {
		m.removedremote_file = make(map[int]struct{})
	}
	for i := range ids {
		m.removedremote_file[ids[i]] = struct{}{}
	}
}

// RemovedRemoteFile returns the removed ids of remote_file.
func (m *ProvisioningStepMutation) RemovedRemoteFileIDs() (ids []int) {
	for id := range m.removedremote_file {
		ids = append(ids, id)
	}
	return
}

// RemoteFileIDs returns the remote_file ids in the mutation.
func (m *ProvisioningStepMutation) RemoteFileIDs() (ids []int) {
	for id := range m.remote_file {
		ids = append(ids, id)
	}
	return
}

// ResetRemoteFile reset all changes of the "remote_file" edge.
func (m *ProvisioningStepMutation) ResetRemoteFile() {
	m.remote_file = nil
	m.clearedremote_file = false
	m.removedremote_file = nil
}

// Op returns the operation name.
func (m *ProvisioningStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisioningStep).
func (m *ProvisioningStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProvisioningStepMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.provisioner_type != nil {
		fields = append(fields, provisioningstep.FieldProvisionerType)
	}
	if m.step_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	if m.status != nil {
		fields = append(fields, provisioningstep.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProvisioningStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldProvisionerType:
		return m.ProvisionerType()
	case provisioningstep.FieldStepNumber:
		return m.StepNumber()
	case provisioningstep.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProvisioningStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisioningstep.FieldProvisionerType:
		return m.OldProvisionerType(ctx)
	case provisioningstep.FieldStepNumber:
		return m.OldStepNumber(ctx)
	case provisioningstep.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvisioningStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldProvisionerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvisionerType(v)
		return nil
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepNumber(v)
		return nil
	case provisioningstep.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProvisioningStepMutation) AddedFields() []string {
	var fields []string
	if m.addstep_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProvisioningStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldStepNumber:
		return m.AddedStepNumber()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProvisioningStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProvisioningStepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProvisioningStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisioningStep nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProvisioningStepMutation) ResetField(name string) error {
	switch name {
	case provisioningstep.FieldProvisionerType:
		m.ResetProvisionerType()
		return nil
	case provisioningstep.FieldStepNumber:
		m.ResetStepNumber()
		return nil
	case provisioningstep.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProvisioningStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.provisioned_host != nil {
		edges = append(edges, provisioningstep.EdgeProvisionedHost)
	}
	if m.script != nil {
		edges = append(edges, provisioningstep.EdgeScript)
	}
	if m.command != nil {
		edges = append(edges, provisioningstep.EdgeCommand)
	}
	if m.dns_record != nil {
		edges = append(edges, provisioningstep.EdgeDNSRecord)
	}
	if m.remote_file != nil {
		edges = append(edges, provisioningstep.EdgeRemoteFile)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProvisioningStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeProvisionedHost:
		ids := make([]ent.Value, 0, len(m.provisioned_host))
		for id := range m.provisioned_host {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeScript:
		ids := make([]ent.Value, 0, len(m.script))
		for id := range m.script {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeCommand:
		ids := make([]ent.Value, 0, len(m.command))
		for id := range m.command {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeDNSRecord:
		ids := make([]ent.Value, 0, len(m.dns_record))
		for id := range m.dns_record {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeRemoteFile:
		ids := make([]ent.Value, 0, len(m.remote_file))
		for id := range m.remote_file {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProvisioningStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprovisioned_host != nil {
		edges = append(edges, provisioningstep.EdgeProvisionedHost)
	}
	if m.removedscript != nil {
		edges = append(edges, provisioningstep.EdgeScript)
	}
	if m.removedcommand != nil {
		edges = append(edges, provisioningstep.EdgeCommand)
	}
	if m.removeddns_record != nil {
		edges = append(edges, provisioningstep.EdgeDNSRecord)
	}
	if m.removedremote_file != nil {
		edges = append(edges, provisioningstep.EdgeRemoteFile)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProvisioningStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeProvisionedHost:
		ids := make([]ent.Value, 0, len(m.removedprovisioned_host))
		for id := range m.removedprovisioned_host {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeScript:
		ids := make([]ent.Value, 0, len(m.removedscript))
		for id := range m.removedscript {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeCommand:
		ids := make([]ent.Value, 0, len(m.removedcommand))
		for id := range m.removedcommand {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeDNSRecord:
		ids := make([]ent.Value, 0, len(m.removeddns_record))
		for id := range m.removeddns_record {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeRemoteFile:
		ids := make([]ent.Value, 0, len(m.removedremote_file))
		for id := range m.removedremote_file {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProvisioningStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedprovisioned_host {
		edges = append(edges, provisioningstep.EdgeProvisionedHost)
	}
	if m.clearedscript {
		edges = append(edges, provisioningstep.EdgeScript)
	}
	if m.clearedcommand {
		edges = append(edges, provisioningstep.EdgeCommand)
	}
	if m.cleareddns_record {
		edges = append(edges, provisioningstep.EdgeDNSRecord)
	}
	if m.clearedremote_file {
		edges = append(edges, provisioningstep.EdgeRemoteFile)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProvisioningStepMutation) EdgeCleared(name string) bool {
	switch name {
	case provisioningstep.EdgeProvisionedHost:
		return m.clearedprovisioned_host
	case provisioningstep.EdgeScript:
		return m.clearedscript
	case provisioningstep.EdgeCommand:
		return m.clearedcommand
	case provisioningstep.EdgeDNSRecord:
		return m.cleareddns_record
	case provisioningstep.EdgeRemoteFile:
		return m.clearedremote_file
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProvisioningStepMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisioningStep unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProvisioningStepMutation) ResetEdge(name string) error {
	switch name {
	case provisioningstep.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case provisioningstep.EdgeScript:
		m.ResetScript()
		return nil
	case provisioningstep.EdgeCommand:
		m.ResetCommand()
		return nil
	case provisioningstep.EdgeDNSRecord:
		m.ResetDNSRecord()
		return nil
	case provisioningstep.EdgeRemoteFile:
		m.ResetRemoteFile()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep edge %s", name)
}

// RemoteFileMutation represents an operation that mutate the RemoteFiles
// nodes in the graph.
type RemoteFileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	source_type   *string
	source        *string
	destination   *string
	vars          *map[string]string
	template      *bool
	perms         *string
	disabled      *bool
	md5           *string
	abs_path      *string
	ext           *string
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*RemoteFile, error)
	predicates    []predicate.RemoteFile
}

var _ ent.Mutation = (*RemoteFileMutation)(nil)

// remotefileOption allows to manage the mutation configuration using functional options.
type remotefileOption func(*RemoteFileMutation)

// newRemoteFileMutation creates new mutation for RemoteFile.
func newRemoteFileMutation(c config, op Op, opts ...remotefileOption) *RemoteFileMutation {
	m := &RemoteFileMutation{
		config:        c,
		op:            op,
		typ:           TypeRemoteFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemoteFileID sets the id field of the mutation.
func withRemoteFileID(id int) remotefileOption {
	return func(m *RemoteFileMutation) {
		var (
			err   error
			once  sync.Once
			value *RemoteFile
		)
		m.oldValue = func(ctx context.Context) (*RemoteFile, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RemoteFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemoteFile sets the old RemoteFile of the mutation.
func withRemoteFile(node *RemoteFile) remotefileOption {
	return func(m *RemoteFileMutation) {
		m.oldValue = func(context.Context) (*RemoteFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemoteFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemoteFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RemoteFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSourceType sets the source_type field.
func (m *RemoteFileMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the source_type value in the mutation.
func (m *RemoteFileMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old source_type value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType reset all changes of the "source_type" field.
func (m *RemoteFileMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSource sets the source field.
func (m *RemoteFileMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the source value in the mutation.
func (m *RemoteFileMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old source value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource reset all changes of the "source" field.
func (m *RemoteFileMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the destination field.
func (m *RemoteFileMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the destination value in the mutation.
func (m *RemoteFileMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old destination value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDestination is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination reset all changes of the "destination" field.
func (m *RemoteFileMutation) ResetDestination() {
	m.destination = nil
}

// SetVars sets the vars field.
func (m *RemoteFileMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the vars value in the mutation.
func (m *RemoteFileMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old vars value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars reset all changes of the "vars" field.
func (m *RemoteFileMutation) ResetVars() {
	m.vars = nil
}

// SetTemplate sets the template field.
func (m *RemoteFileMutation) SetTemplate(b bool) {
	m.template = &b
}

// Template returns the template value in the mutation.
func (m *RemoteFileMutation) Template() (r bool, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old template value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate reset all changes of the "template" field.
func (m *RemoteFileMutation) ResetTemplate() {
	m.template = nil
}

// SetPerms sets the perms field.
func (m *RemoteFileMutation) SetPerms(s string) {
	m.perms = &s
}

// Perms returns the perms value in the mutation.
func (m *RemoteFileMutation) Perms() (r string, exists bool) {
	v := m.perms
	if v == nil {
		return
	}
	return *v, true
}

// OldPerms returns the old perms value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldPerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPerms is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerms: %w", err)
	}
	return oldValue.Perms, nil
}

// ResetPerms reset all changes of the "perms" field.
func (m *RemoteFileMutation) ResetPerms() {
	m.perms = nil
}

// SetDisabled sets the disabled field.
func (m *RemoteFileMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the disabled value in the mutation.
func (m *RemoteFileMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old disabled value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled reset all changes of the "disabled" field.
func (m *RemoteFileMutation) ResetDisabled() {
	m.disabled = nil
}

// SetMd5 sets the md5 field.
func (m *RemoteFileMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the md5 value in the mutation.
func (m *RemoteFileMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old md5 value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMd5 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 reset all changes of the "md5" field.
func (m *RemoteFileMutation) ResetMd5() {
	m.md5 = nil
}

// SetAbsPath sets the abs_path field.
func (m *RemoteFileMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the abs_path value in the mutation.
func (m *RemoteFileMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old abs_path value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbsPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath reset all changes of the "abs_path" field.
func (m *RemoteFileMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetExt sets the ext field.
func (m *RemoteFileMutation) SetExt(s string) {
	m.ext = &s
}

// Ext returns the ext value in the mutation.
func (m *RemoteFileMutation) Ext() (r string, exists bool) {
	v := m.ext
	if v == nil {
		return
	}
	return *v, true
}

// OldExt returns the old ext value of the RemoteFile.
// If the RemoteFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RemoteFileMutation) OldExt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExt: %w", err)
	}
	return oldValue.Ext, nil
}

// ResetExt reset all changes of the "ext" field.
func (m *RemoteFileMutation) ResetExt() {
	m.ext = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *RemoteFileMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *RemoteFileMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *RemoteFileMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *RemoteFileMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *RemoteFileMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *RemoteFileMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *RemoteFileMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *RemoteFileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RemoteFile).
func (m *RemoteFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RemoteFileMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.source_type != nil {
		fields = append(fields, remotefile.FieldSourceType)
	}
	if m.source != nil {
		fields = append(fields, remotefile.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, remotefile.FieldDestination)
	}
	if m.vars != nil {
		fields = append(fields, remotefile.FieldVars)
	}
	if m.template != nil {
		fields = append(fields, remotefile.FieldTemplate)
	}
	if m.perms != nil {
		fields = append(fields, remotefile.FieldPerms)
	}
	if m.disabled != nil {
		fields = append(fields, remotefile.FieldDisabled)
	}
	if m.md5 != nil {
		fields = append(fields, remotefile.FieldMd5)
	}
	if m.abs_path != nil {
		fields = append(fields, remotefile.FieldAbsPath)
	}
	if m.ext != nil {
		fields = append(fields, remotefile.FieldExt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RemoteFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remotefile.FieldSourceType:
		return m.SourceType()
	case remotefile.FieldSource:
		return m.Source()
	case remotefile.FieldDestination:
		return m.Destination()
	case remotefile.FieldVars:
		return m.Vars()
	case remotefile.FieldTemplate:
		return m.Template()
	case remotefile.FieldPerms:
		return m.Perms()
	case remotefile.FieldDisabled:
		return m.Disabled()
	case remotefile.FieldMd5:
		return m.Md5()
	case remotefile.FieldAbsPath:
		return m.AbsPath()
	case remotefile.FieldExt:
		return m.Ext()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RemoteFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remotefile.FieldSourceType:
		return m.OldSourceType(ctx)
	case remotefile.FieldSource:
		return m.OldSource(ctx)
	case remotefile.FieldDestination:
		return m.OldDestination(ctx)
	case remotefile.FieldVars:
		return m.OldVars(ctx)
	case remotefile.FieldTemplate:
		return m.OldTemplate(ctx)
	case remotefile.FieldPerms:
		return m.OldPerms(ctx)
	case remotefile.FieldDisabled:
		return m.OldDisabled(ctx)
	case remotefile.FieldMd5:
		return m.OldMd5(ctx)
	case remotefile.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case remotefile.FieldExt:
		return m.OldExt(ctx)
	}
	return nil, fmt.Errorf("unknown RemoteFile field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RemoteFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remotefile.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case remotefile.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case remotefile.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case remotefile.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case remotefile.FieldTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case remotefile.FieldPerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerms(v)
		return nil
	case remotefile.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case remotefile.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case remotefile.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case remotefile.FieldExt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExt(v)
		return nil
	}
	return fmt.Errorf("unknown RemoteFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RemoteFileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RemoteFileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RemoteFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RemoteFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RemoteFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RemoteFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemoteFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RemoteFile nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RemoteFileMutation) ResetField(name string) error {
	switch name {
	case remotefile.FieldSourceType:
		m.ResetSourceType()
		return nil
	case remotefile.FieldSource:
		m.ResetSource()
		return nil
	case remotefile.FieldDestination:
		m.ResetDestination()
		return nil
	case remotefile.FieldVars:
		m.ResetVars()
		return nil
	case remotefile.FieldTemplate:
		m.ResetTemplate()
		return nil
	case remotefile.FieldPerms:
		m.ResetPerms()
		return nil
	case remotefile.FieldDisabled:
		m.ResetDisabled()
		return nil
	case remotefile.FieldMd5:
		m.ResetMd5()
		return nil
	case remotefile.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case remotefile.FieldExt:
		m.ResetExt()
		return nil
	}
	return fmt.Errorf("unknown RemoteFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RemoteFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, remotefile.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RemoteFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case remotefile.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RemoteFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, remotefile.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RemoteFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case remotefile.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RemoteFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, remotefile.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RemoteFileMutation) EdgeCleared(name string) bool {
	switch name {
	case remotefile.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RemoteFileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RemoteFile unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RemoteFileMutation) ResetEdge(name string) error {
	switch name {
	case remotefile.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown RemoteFile edge %s", name)
}

// ScriptMutation represents an operation that mutate the Scripts
// nodes in the graph.
type ScriptMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	language          *string
	description       *string
	source            *string
	source_type       *string
	cooldown          *int
	addcooldown       *int
	timeout           *int
	addtimeout        *int
	ignore_errors     *bool
	args              *[]string
	disabled          *bool
	vars              *map[string]string
	abs_path          *string
	clearedFields     map[string]struct{}
	tag               map[int]struct{}
	removedtag        map[int]struct{}
	clearedtag        bool
	maintainer        map[int]struct{}
	removedmaintainer map[int]struct{}
	clearedmaintainer bool
	finding           map[int]struct{}
	removedfinding    map[int]struct{}
	clearedfinding    bool
	done              bool
	oldValue          func(context.Context) (*Script, error)
	predicates        []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows to manage the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for Script.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the id field of the mutation.
func withScriptID(id int) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ScriptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ScriptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ScriptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ScriptMutation) ResetName() {
	m.name = nil
}

// SetLanguage sets the language field.
func (m *ScriptMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the language value in the mutation.
func (m *ScriptMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old language value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLanguage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage reset all changes of the "language" field.
func (m *ScriptMutation) ResetLanguage() {
	m.language = nil
}

// SetDescription sets the description field.
func (m *ScriptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ScriptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *ScriptMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the source field.
func (m *ScriptMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the source value in the mutation.
func (m *ScriptMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old source value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource reset all changes of the "source" field.
func (m *ScriptMutation) ResetSource() {
	m.source = nil
}

// SetSourceType sets the source_type field.
func (m *ScriptMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the source_type value in the mutation.
func (m *ScriptMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old source_type value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType reset all changes of the "source_type" field.
func (m *ScriptMutation) ResetSourceType() {
	m.source_type = nil
}

// SetCooldown sets the cooldown field.
func (m *ScriptMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the cooldown value in the mutation.
func (m *ScriptMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old cooldown value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCooldown is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to cooldown.
func (m *ScriptMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the cooldown field in this mutation.
func (m *ScriptMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown reset all changes of the "cooldown" field.
func (m *ScriptMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the timeout field.
func (m *ScriptMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the timeout value in the mutation.
func (m *ScriptMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old timeout value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to timeout.
func (m *ScriptMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the timeout field in this mutation.
func (m *ScriptMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout reset all changes of the "timeout" field.
func (m *ScriptMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetIgnoreErrors sets the ignore_errors field.
func (m *ScriptMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the ignore_errors value in the mutation.
func (m *ScriptMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old ignore_errors value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIgnoreErrors is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors reset all changes of the "ignore_errors" field.
func (m *ScriptMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetArgs sets the args field.
func (m *ScriptMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the args value in the mutation.
func (m *ScriptMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old args value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArgs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs reset all changes of the "args" field.
func (m *ScriptMutation) ResetArgs() {
	m.args = nil
}

// SetDisabled sets the disabled field.
func (m *ScriptMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the disabled value in the mutation.
func (m *ScriptMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old disabled value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled reset all changes of the "disabled" field.
func (m *ScriptMutation) ResetDisabled() {
	m.disabled = nil
}

// SetVars sets the vars field.
func (m *ScriptMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the vars value in the mutation.
func (m *ScriptMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old vars value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars reset all changes of the "vars" field.
func (m *ScriptMutation) ResetVars() {
	m.vars = nil
}

// SetAbsPath sets the abs_path field.
func (m *ScriptMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the abs_path value in the mutation.
func (m *ScriptMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old abs_path value of the Script.
// If the Script object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScriptMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbsPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath reset all changes of the "abs_path" field.
func (m *ScriptMutation) ResetAbsPath() {
	m.abs_path = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *ScriptMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *ScriptMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *ScriptMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *ScriptMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *ScriptMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *ScriptMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *ScriptMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddMaintainerIDs adds the maintainer edge to User by ids.
func (m *ScriptMutation) AddMaintainerIDs(ids ...int) {
	if m.maintainer == nil {
		m.maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.maintainer[ids[i]] = struct{}{}
	}
}

// ClearMaintainer clears the maintainer edge to User.
func (m *ScriptMutation) ClearMaintainer() {
	m.clearedmaintainer = true
}

// MaintainerCleared returns if the edge maintainer was cleared.
func (m *ScriptMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// RemoveMaintainerIDs removes the maintainer edge to User by ids.
func (m *ScriptMutation) RemoveMaintainerIDs(ids ...int) {
	if m.removedmaintainer == nil {
		m.removedmaintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmaintainer[ids[i]] = struct{}{}
	}
}

// RemovedMaintainer returns the removed ids of maintainer.
func (m *ScriptMutation) RemovedMaintainerIDs() (ids []int) {
	for id := range m.removedmaintainer {
		ids = append(ids, id)
	}
	return
}

// MaintainerIDs returns the maintainer ids in the mutation.
func (m *ScriptMutation) MaintainerIDs() (ids []int) {
	for id := range m.maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetMaintainer reset all changes of the "maintainer" edge.
func (m *ScriptMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
	m.removedmaintainer = nil
}

// AddFindingIDs adds the finding edge to Finding by ids.
func (m *ScriptMutation) AddFindingIDs(ids ...int) {
	if m.finding == nil {
		m.finding = make(map[int]struct{})
	}
	for i := range ids {
		m.finding[ids[i]] = struct{}{}
	}
}

// ClearFinding clears the finding edge to Finding.
func (m *ScriptMutation) ClearFinding() {
	m.clearedfinding = true
}

// FindingCleared returns if the edge finding was cleared.
func (m *ScriptMutation) FindingCleared() bool {
	return m.clearedfinding
}

// RemoveFindingIDs removes the finding edge to Finding by ids.
func (m *ScriptMutation) RemoveFindingIDs(ids ...int) {
	if m.removedfinding == nil {
		m.removedfinding = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfinding[ids[i]] = struct{}{}
	}
}

// RemovedFinding returns the removed ids of finding.
func (m *ScriptMutation) RemovedFindingIDs() (ids []int) {
	for id := range m.removedfinding {
		ids = append(ids, id)
	}
	return
}

// FindingIDs returns the finding ids in the mutation.
func (m *ScriptMutation) FindingIDs() (ids []int) {
	for id := range m.finding {
		ids = append(ids, id)
	}
	return
}

// ResetFinding reset all changes of the "finding" edge.
func (m *ScriptMutation) ResetFinding() {
	m.finding = nil
	m.clearedfinding = false
	m.removedfinding = nil
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, script.FieldName)
	}
	if m.language != nil {
		fields = append(fields, script.FieldLanguage)
	}
	if m.description != nil {
		fields = append(fields, script.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, script.FieldSource)
	}
	if m.source_type != nil {
		fields = append(fields, script.FieldSourceType)
	}
	if m.cooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	if m.ignore_errors != nil {
		fields = append(fields, script.FieldIgnoreErrors)
	}
	if m.args != nil {
		fields = append(fields, script.FieldArgs)
	}
	if m.disabled != nil {
		fields = append(fields, script.FieldDisabled)
	}
	if m.vars != nil {
		fields = append(fields, script.FieldVars)
	}
	if m.abs_path != nil {
		fields = append(fields, script.FieldAbsPath)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldName:
		return m.Name()
	case script.FieldLanguage:
		return m.Language()
	case script.FieldDescription:
		return m.Description()
	case script.FieldSource:
		return m.Source()
	case script.FieldSourceType:
		return m.SourceType()
	case script.FieldCooldown:
		return m.Cooldown()
	case script.FieldTimeout:
		return m.Timeout()
	case script.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case script.FieldArgs:
		return m.Args()
	case script.FieldDisabled:
		return m.Disabled()
	case script.FieldVars:
		return m.Vars()
	case script.FieldAbsPath:
		return m.AbsPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldName:
		return m.OldName(ctx)
	case script.FieldLanguage:
		return m.OldLanguage(ctx)
	case script.FieldDescription:
		return m.OldDescription(ctx)
	case script.FieldSource:
		return m.OldSource(ctx)
	case script.FieldSourceType:
		return m.OldSourceType(ctx)
	case script.FieldCooldown:
		return m.OldCooldown(ctx)
	case script.FieldTimeout:
		return m.OldTimeout(ctx)
	case script.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case script.FieldArgs:
		return m.OldArgs(ctx)
	case script.FieldDisabled:
		return m.OldDisabled(ctx)
	case script.FieldVars:
		return m.OldVars(ctx)
	case script.FieldAbsPath:
		return m.OldAbsPath(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case script.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case script.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case script.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case script.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case script.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case script.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case script.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case script.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case script.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ScriptMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case script.FieldCooldown:
		return m.AddedCooldown()
	case script.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ScriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldName:
		m.ResetName()
		return nil
	case script.FieldLanguage:
		m.ResetLanguage()
		return nil
	case script.FieldDescription:
		m.ResetDescription()
		return nil
	case script.FieldSource:
		m.ResetSource()
		return nil
	case script.FieldSourceType:
		m.ResetSourceType()
		return nil
	case script.FieldCooldown:
		m.ResetCooldown()
		return nil
	case script.FieldTimeout:
		m.ResetTimeout()
		return nil
	case script.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case script.FieldArgs:
		m.ResetArgs()
		return nil
	case script.FieldDisabled:
		m.ResetDisabled()
		return nil
	case script.FieldVars:
		m.ResetVars()
		return nil
	case script.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tag != nil {
		edges = append(edges, script.EdgeTag)
	}
	if m.maintainer != nil {
		edges = append(edges, script.EdgeMaintainer)
	}
	if m.finding != nil {
		edges = append(edges, script.EdgeFinding)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.maintainer))
		for id := range m.maintainer {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeFinding:
		ids := make([]ent.Value, 0, len(m.finding))
		for id := range m.finding {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtag != nil {
		edges = append(edges, script.EdgeTag)
	}
	if m.removedmaintainer != nil {
		edges = append(edges, script.EdgeMaintainer)
	}
	if m.removedfinding != nil {
		edges = append(edges, script.EdgeFinding)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.removedmaintainer))
		for id := range m.removedmaintainer {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeFinding:
		ids := make([]ent.Value, 0, len(m.removedfinding))
		for id := range m.removedfinding {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtag {
		edges = append(edges, script.EdgeTag)
	}
	if m.clearedmaintainer {
		edges = append(edges, script.EdgeMaintainer)
	}
	if m.clearedfinding {
		edges = append(edges, script.EdgeFinding)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	switch name {
	case script.EdgeTag:
		return m.clearedtag
	case script.EdgeMaintainer:
		return m.clearedmaintainer
	case script.EdgeFinding:
		return m.clearedfinding
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	switch name {
	case script.EdgeTag:
		m.ResetTag()
		return nil
	case script.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	case script.EdgeFinding:
		m.ResetFinding()
		return nil
	}
	return fmt.Errorf("unknown Script edge %s", name)
}

// StatusMutation represents an operation that mutate the StatusSlice
// nodes in the graph.
type StatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	state         *status.State
	started_at    *time.Time
	ended_at      *time.Time
	failed        *bool
	completed     *bool
	error         *string
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*Status, error)
	predicates    []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows to manage the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for Status.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the id field of the mutation.
func withStatusID(id int) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetState sets the state field.
func (m *StatusMutation) SetState(s status.State) {
	m.state = &s
}

// State returns the state value in the mutation.
func (m *StatusMutation) State() (r status.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old state value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldState(ctx context.Context) (v status.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState reset all changes of the "state" field.
func (m *StatusMutation) ResetState() {
	m.state = nil
}

// SetStartedAt sets the started_at field.
func (m *StatusMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the started_at value in the mutation.
func (m *StatusMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old started_at value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt reset all changes of the "started_at" field.
func (m *StatusMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the ended_at field.
func (m *StatusMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the ended_at value in the mutation.
func (m *StatusMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old ended_at value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt reset all changes of the "ended_at" field.
func (m *StatusMutation) ResetEndedAt() {
	m.ended_at = nil
}

// SetFailed sets the failed field.
func (m *StatusMutation) SetFailed(b bool) {
	m.failed = &b
}

// Failed returns the failed value in the mutation.
func (m *StatusMutation) Failed() (r bool, exists bool) {
	v := m.failed
	if v == nil {
		return
	}
	return *v, true
}

// OldFailed returns the old failed value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldFailed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFailed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailed: %w", err)
	}
	return oldValue.Failed, nil
}

// ResetFailed reset all changes of the "failed" field.
func (m *StatusMutation) ResetFailed() {
	m.failed = nil
}

// SetCompleted sets the completed field.
func (m *StatusMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the completed value in the mutation.
func (m *StatusMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old completed value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted reset all changes of the "completed" field.
func (m *StatusMutation) ResetCompleted() {
	m.completed = nil
}

// SetError sets the error field.
func (m *StatusMutation) SetError(s string) {
	m.error = &s
}

// Error returns the error value in the mutation.
func (m *StatusMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old error value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldError is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError reset all changes of the "error" field.
func (m *StatusMutation) ResetError() {
	m.error = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *StatusMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *StatusMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *StatusMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *StatusMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *StatusMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *StatusMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *StatusMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.state != nil {
		fields = append(fields, status.FieldState)
	}
	if m.started_at != nil {
		fields = append(fields, status.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, status.FieldEndedAt)
	}
	if m.failed != nil {
		fields = append(fields, status.FieldFailed)
	}
	if m.completed != nil {
		fields = append(fields, status.FieldCompleted)
	}
	if m.error != nil {
		fields = append(fields, status.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldState:
		return m.State()
	case status.FieldStartedAt:
		return m.StartedAt()
	case status.FieldEndedAt:
		return m.EndedAt()
	case status.FieldFailed:
		return m.Failed()
	case status.FieldCompleted:
		return m.Completed()
	case status.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldState:
		return m.OldState(ctx)
	case status.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case status.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case status.FieldFailed:
		return m.OldFailed(ctx)
	case status.FieldCompleted:
		return m.OldCompleted(ctx)
	case status.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldState:
		v, ok := value.(status.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case status.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case status.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case status.FieldFailed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailed(v)
		return nil
	case status.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case status.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldState:
		m.ResetState()
		return nil
	case status.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case status.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case status.FieldFailed:
		m.ResetFailed()
		return nil
	case status.FieldCompleted:
		m.ResetCompleted()
		return nil
	case status.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, status.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, status.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, status.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	case status.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// TagMutation represents an operation that mutate the Tags
// nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	name          *string
	description   *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows to manage the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for Tag.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the id field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the uuid field.
func (m *TagMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the uuid value in the mutation.
func (m *TagMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old uuid value of the Tag.
// If the Tag object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID reset all changes of the "uuid" field.
func (m *TagMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the name field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Tag.
// If the Tag object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *TagMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the description value in the mutation.
func (m *TagMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Tag.
// If the Tag object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, tag.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUUID:
		return m.UUID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUUID:
		return m.OldUUID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUUID:
		m.ResetUUID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TeamMutation represents an operation that mutate the Teams
// nodes in the graph.
type TeamMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	team_number                 *int
	addteam_number              *int
	_config                     *map[string]string
	revision                    *int64
	addrevision                 *int64
	clearedFields               map[string]struct{}
	maintainer                  map[int]struct{}
	removedmaintainer           map[int]struct{}
	clearedmaintainer           bool
	build                       map[int]struct{}
	removedbuild                map[int]struct{}
	clearedbuild                bool
	_TeamToEnvironment          map[int]struct{}
	removed_TeamToEnvironment   map[int]struct{}
	cleared_TeamToEnvironment   bool
	tag                         map[int]struct{}
	removedtag                  map[int]struct{}
	clearedtag                  bool
	provisioned_networks        map[int]struct{}
	removedprovisioned_networks map[int]struct{}
	clearedprovisioned_networks bool
	done                        bool
	oldValue                    func(context.Context) (*Team, error)
	predicates                  []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows to manage the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for Team.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the id field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTeamNumber sets the team_number field.
func (m *TeamMutation) SetTeamNumber(i int) {
	m.team_number = &i
	m.addteam_number = nil
}

// TeamNumber returns the team_number value in the mutation.
func (m *TeamMutation) TeamNumber() (r int, exists bool) {
	v := m.team_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamNumber returns the old team_number value of the Team.
// If the Team object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TeamMutation) OldTeamNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeamNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeamNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamNumber: %w", err)
	}
	return oldValue.TeamNumber, nil
}

// AddTeamNumber adds i to team_number.
func (m *TeamMutation) AddTeamNumber(i int) {
	if m.addteam_number != nil {
		*m.addteam_number += i
	} else {
		m.addteam_number = &i
	}
}

// AddedTeamNumber returns the value that was added to the team_number field in this mutation.
func (m *TeamMutation) AddedTeamNumber() (r int, exists bool) {
	v := m.addteam_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamNumber reset all changes of the "team_number" field.
func (m *TeamMutation) ResetTeamNumber() {
	m.team_number = nil
	m.addteam_number = nil
}

// SetConfig sets the config field.
func (m *TeamMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the config value in the mutation.
func (m *TeamMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old config value of the Team.
// If the Team object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TeamMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig reset all changes of the "config" field.
func (m *TeamMutation) ResetConfig() {
	m._config = nil
}

// SetRevision sets the revision field.
func (m *TeamMutation) SetRevision(i int64) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the revision value in the mutation.
func (m *TeamMutation) Revision() (r int64, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old revision value of the Team.
// If the Team object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TeamMutation) OldRevision(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to revision.
func (m *TeamMutation) AddRevision(i int64) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the revision field in this mutation.
func (m *TeamMutation) AddedRevision() (r int64, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision reset all changes of the "revision" field.
func (m *TeamMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// AddMaintainerIDs adds the maintainer edge to User by ids.
func (m *TeamMutation) AddMaintainerIDs(ids ...int) {
	if m.maintainer == nil {
		m.maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.maintainer[ids[i]] = struct{}{}
	}
}

// ClearMaintainer clears the maintainer edge to User.
func (m *TeamMutation) ClearMaintainer() {
	m.clearedmaintainer = true
}

// MaintainerCleared returns if the edge maintainer was cleared.
func (m *TeamMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// RemoveMaintainerIDs removes the maintainer edge to User by ids.
func (m *TeamMutation) RemoveMaintainerIDs(ids ...int) {
	if m.removedmaintainer == nil {
		m.removedmaintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmaintainer[ids[i]] = struct{}{}
	}
}

// RemovedMaintainer returns the removed ids of maintainer.
func (m *TeamMutation) RemovedMaintainerIDs() (ids []int) {
	for id := range m.removedmaintainer {
		ids = append(ids, id)
	}
	return
}

// MaintainerIDs returns the maintainer ids in the mutation.
func (m *TeamMutation) MaintainerIDs() (ids []int) {
	for id := range m.maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetMaintainer reset all changes of the "maintainer" edge.
func (m *TeamMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
	m.removedmaintainer = nil
}

// AddBuildIDs adds the build edge to Build by ids.
func (m *TeamMutation) AddBuildIDs(ids ...int) {
	if m.build == nil {
		m.build = make(map[int]struct{})
	}
	for i := range ids {
		m.build[ids[i]] = struct{}{}
	}
}

// ClearBuild clears the build edge to Build.
func (m *TeamMutation) ClearBuild() {
	m.clearedbuild = true
}

// BuildCleared returns if the edge build was cleared.
func (m *TeamMutation) BuildCleared() bool {
	return m.clearedbuild
}

// RemoveBuildIDs removes the build edge to Build by ids.
func (m *TeamMutation) RemoveBuildIDs(ids ...int) {
	if m.removedbuild == nil {
		m.removedbuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbuild[ids[i]] = struct{}{}
	}
}

// RemovedBuild returns the removed ids of build.
func (m *TeamMutation) RemovedBuildIDs() (ids []int) {
	for id := range m.removedbuild {
		ids = append(ids, id)
	}
	return
}

// BuildIDs returns the build ids in the mutation.
func (m *TeamMutation) BuildIDs() (ids []int) {
	for id := range m.build {
		ids = append(ids, id)
	}
	return
}

// ResetBuild reset all changes of the "build" edge.
func (m *TeamMutation) ResetBuild() {
	m.build = nil
	m.clearedbuild = false
	m.removedbuild = nil
}

// AddTeamToEnvironmentIDs adds the TeamToEnvironment edge to Environment by ids.
func (m *TeamMutation) AddTeamToEnvironmentIDs(ids ...int) {
	if m._TeamToEnvironment == nil {
		m._TeamToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._TeamToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearTeamToEnvironment clears the TeamToEnvironment edge to Environment.
func (m *TeamMutation) ClearTeamToEnvironment() {
	m.cleared_TeamToEnvironment = true
}

// TeamToEnvironmentCleared returns if the edge TeamToEnvironment was cleared.
func (m *TeamMutation) TeamToEnvironmentCleared() bool {
	return m.cleared_TeamToEnvironment
}

// RemoveTeamToEnvironmentIDs removes the TeamToEnvironment edge to Environment by ids.
func (m *TeamMutation) RemoveTeamToEnvironmentIDs(ids ...int) {
	if m.removed_TeamToEnvironment == nil {
		m.removed_TeamToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TeamToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedTeamToEnvironment returns the removed ids of TeamToEnvironment.
func (m *TeamMutation) RemovedTeamToEnvironmentIDs() (ids []int) {
	for id := range m.removed_TeamToEnvironment {
		ids = append(ids, id)
	}
	return
}

// TeamToEnvironmentIDs returns the TeamToEnvironment ids in the mutation.
func (m *TeamMutation) TeamToEnvironmentIDs() (ids []int) {
	for id := range m._TeamToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToEnvironment reset all changes of the "TeamToEnvironment" edge.
func (m *TeamMutation) ResetTeamToEnvironment() {
	m._TeamToEnvironment = nil
	m.cleared_TeamToEnvironment = false
	m.removed_TeamToEnvironment = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *TeamMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *TeamMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *TeamMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *TeamMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *TeamMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *TeamMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *TeamMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddProvisionedNetworkIDs adds the provisioned_networks edge to ProvisionedNetwork by ids.
func (m *TeamMutation) AddProvisionedNetworkIDs(ids ...int) {
	if m.provisioned_networks == nil {
		m.provisioned_networks = make(map[int]struct{})
	}
	for i := range ids {
		m.provisioned_networks[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworks clears the provisioned_networks edge to ProvisionedNetwork.
func (m *TeamMutation) ClearProvisionedNetworks() {
	m.clearedprovisioned_networks = true
}

// ProvisionedNetworksCleared returns if the edge provisioned_networks was cleared.
func (m *TeamMutation) ProvisionedNetworksCleared() bool {
	return m.clearedprovisioned_networks
}

// RemoveProvisionedNetworkIDs removes the provisioned_networks edge to ProvisionedNetwork by ids.
func (m *TeamMutation) RemoveProvisionedNetworkIDs(ids ...int) {
	if m.removedprovisioned_networks == nil {
		m.removedprovisioned_networks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprovisioned_networks[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworks returns the removed ids of provisioned_networks.
func (m *TeamMutation) RemovedProvisionedNetworksIDs() (ids []int) {
	for id := range m.removedprovisioned_networks {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworksIDs returns the provisioned_networks ids in the mutation.
func (m *TeamMutation) ProvisionedNetworksIDs() (ids []int) {
	for id := range m.provisioned_networks {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworks reset all changes of the "provisioned_networks" edge.
func (m *TeamMutation) ResetProvisionedNetworks() {
	m.provisioned_networks = nil
	m.clearedprovisioned_networks = false
	m.removedprovisioned_networks = nil
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.team_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	if m._config != nil {
		fields = append(fields, team.FieldConfig)
	}
	if m.revision != nil {
		fields = append(fields, team.FieldRevision)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.TeamNumber()
	case team.FieldConfig:
		return m.Config()
	case team.FieldRevision:
		return m.Revision()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldTeamNumber:
		return m.OldTeamNumber(ctx)
	case team.FieldConfig:
		return m.OldConfig(ctx)
	case team.FieldRevision:
		return m.OldRevision(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamNumber(v)
		return nil
	case team.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case team.FieldRevision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addteam_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	if m.addrevision != nil {
		fields = append(fields, team.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.AddedTeamNumber()
	case team.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamNumber(v)
		return nil
	case team.FieldRevision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldTeamNumber:
		m.ResetTeamNumber()
		return nil
	case team.FieldConfig:
		m.ResetConfig()
		return nil
	case team.FieldRevision:
		m.ResetRevision()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.maintainer != nil {
		edges = append(edges, team.EdgeMaintainer)
	}
	if m.build != nil {
		edges = append(edges, team.EdgeBuild)
	}
	if m._TeamToEnvironment != nil {
		edges = append(edges, team.EdgeTeamToEnvironment)
	}
	if m.tag != nil {
		edges = append(edges, team.EdgeTag)
	}
	if m.provisioned_networks != nil {
		edges = append(edges, team.EdgeProvisionedNetworks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.maintainer))
		for id := range m.maintainer {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeBuild:
		ids := make([]ent.Value, 0, len(m.build))
		for id := range m.build {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToEnvironment:
		ids := make([]ent.Value, 0, len(m._TeamToEnvironment))
		for id := range m._TeamToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeProvisionedNetworks:
		ids := make([]ent.Value, 0, len(m.provisioned_networks))
		for id := range m.provisioned_networks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmaintainer != nil {
		edges = append(edges, team.EdgeMaintainer)
	}
	if m.removedbuild != nil {
		edges = append(edges, team.EdgeBuild)
	}
	if m.removed_TeamToEnvironment != nil {
		edges = append(edges, team.EdgeTeamToEnvironment)
	}
	if m.removedtag != nil {
		edges = append(edges, team.EdgeTag)
	}
	if m.removedprovisioned_networks != nil {
		edges = append(edges, team.EdgeProvisionedNetworks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMaintainer:
		ids := make([]ent.Value, 0, len(m.removedmaintainer))
		for id := range m.removedmaintainer {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeBuild:
		ids := make([]ent.Value, 0, len(m.removedbuild))
		for id := range m.removedbuild {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_TeamToEnvironment))
		for id := range m.removed_TeamToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeProvisionedNetworks:
		ids := make([]ent.Value, 0, len(m.removedprovisioned_networks))
		for id := range m.removedprovisioned_networks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmaintainer {
		edges = append(edges, team.EdgeMaintainer)
	}
	if m.clearedbuild {
		edges = append(edges, team.EdgeBuild)
	}
	if m.cleared_TeamToEnvironment {
		edges = append(edges, team.EdgeTeamToEnvironment)
	}
	if m.clearedtag {
		edges = append(edges, team.EdgeTag)
	}
	if m.clearedprovisioned_networks {
		edges = append(edges, team.EdgeProvisionedNetworks)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeMaintainer:
		return m.clearedmaintainer
	case team.EdgeBuild:
		return m.clearedbuild
	case team.EdgeTeamToEnvironment:
		return m.cleared_TeamToEnvironment
	case team.EdgeTag:
		return m.clearedtag
	case team.EdgeProvisionedNetworks:
		return m.clearedprovisioned_networks
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	case team.EdgeBuild:
		m.ResetBuild()
		return nil
	case team.EdgeTeamToEnvironment:
		m.ResetTeamToEnvironment()
		return nil
	case team.EdgeTag:
		m.ResetTag()
		return nil
	case team.EdgeProvisionedNetworks:
		m.ResetProvisionedNetworks()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	uuid          *string
	email         *string
	clearedFields map[string]struct{}
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for User.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUUID sets the uuid field.
func (m *UserMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the uuid value in the mutation.
func (m *UserMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old uuid value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID reset all changes of the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddTagIDs adds the tag edge to Tag by ids.
func (m *UserMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the tag edge to Tag.
func (m *UserMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared returns if the edge tag was cleared.
func (m *UserMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the tag edge to Tag by ids.
func (m *UserMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed ids of tag.
func (m *UserMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the tag ids in the mutation.
func (m *UserMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag reset all changes of the "tag" edge.
func (m *UserMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, user.EdgeTag)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, user.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, user.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
